[
  
  {
    "title"    : "(Deep Dive Study)웹 브라우저에 naver.com URL을 입력하면 어떤 일이 생기나요? + 이론을 통한 렌더링 최적화 고민",
    "category" : "",
    "tags"     : " Javascript, Browser, Rendering",
    "url"      : "/syntax/2023/09/17/Browser-rendering.html",
    "date"     : "September 17, 2023",
    "excerpt"  : "🌱  이 토픽에 관해\n\n스터디에서 발표 자료를 준비하기 위해 정리하였으며, 프론트엔드 엔지니어 포지션으로 면접을 보며 많이 받은 질문이다.\n\n“웹 브라우저에 naver.com URL을 입력하면 어떤 일이 생기나요?”\n\n이론상으로 외우며 공부한 부분을 좀 더 깊게 파해쳐서 정리해보기로 했다.\n\n우선적으로, 해당 부분을 깊게 정리하려면 사전에 웹 브라우저가 사이트에 접속할 경우의 동작 순서를 간략하게 정리할 필요가 있다고 생각한다.\n\n\n\n🌑 ...",
  "content"  : "🌱  이 토픽에 관해\n\n스터디에서 발표 자료를 준비하기 위해 정리하였으며, 프론트엔드 엔지니어 포지션으로 면접을 보며 많이 받은 질문이다.\n\n“웹 브라우저에 naver.com URL을 입력하면 어떤 일이 생기나요?”\n\n이론상으로 외우며 공부한 부분을 좀 더 깊게 파해쳐서 정리해보기로 했다.\n\n우선적으로, 해당 부분을 깊게 정리하려면 사전에 웹 브라우저가 사이트에 접속할 경우의 동작 순서를 간략하게 정리할 필요가 있다고 생각한다.\n\n\n\n🌑 웹 브라우저와 웹 브라우저의 동작에 관해\n\n우리가 웹 서핑을 위해 익히 사용하는 웹 브라우저는 보통 웹 서버와 통신하고 다양한 사이트 내부의 컨텐츠를 볼 수 있도록 지원하는 소프트웨어이다.\n\n\n\n브라우저는 다양한 종류의 브라우저가 있으며, 해당 브라우저마다 엔진이 다르기 때문에 퍼블리셔와 프론트엔드 엔지니어는 Cross Browsing에 유의하며 자바스크립트와 CSS를 작성해야 한다.\n\n\n\n출처 : mozilla.org (MDN web docs)\n\n\n\n🌒 그럼 웹 브라우저는 어떻게 동작해 ? (웹 브라우저의 동작 순서)\n\n동작 순서와 토픽 정리\n\n\n  사용자가 웹 브라우저 주소창에 URL을 입력하면, 웹 브라우저는 DNS에게 해당 호스트의 IP주소를 묻게 된다.\n    \n      일반 사용자는 naver.com과 같은 Domain Name을 통해 정보에 엑세스하게 되는데, 웹 브라우저는 인터넷 프로토콜(IP) 주소를 통해 상호작용 하므로 DNS는 브라우저가 인터넷 자원을 로드할 수 있도록 도메인 이름을 IP주소로 변환하는 작업을 행해준다.\n      DNS(Domain Name System) : IP 주소 및 기타 데이터를 저장하고 이름별로 쿼리할 수 있게 해주는 분산 데이터베이스이다. 쉽게 표현하면 인터넷 상의 전화번호부와 같다.\n    \n  \n  브라우저는 해당 호스트의 IP주소로 서버를 찾아간다. 이때 브라우저는 번호표 역할을 하는 ISN(Random Sequence)를 가지고 간다.\n    \n      ISN (Random Sequence) : TCP 기반 데이터 통신에서 각각의 새 연결에 할당된 고유한 32비트 시퀀스 번호를 나타낸다. TCP 연결을 통해 전송되는 다른 데이터 바이트와 충돌하지 않는 시퀀스 번호를 할당하는데 도움이 된다. ( 통신마다 충돌이 일어나지 않기 위한 목적 )\n    \n  \n  서버는 ISN(Random Sequence)를 가지고 1을 더한 후 다시 브라우저에게 주고, 브라우저는 서버에게 응답받은 ISN(Random Sequence)에 다시 한 번 1을 더해 서버에 보내며 데이터를 주고 받기 위한 3 Way-Handshake 를 완료한다.\n    \n      3 Way-Handshake : 3개의 단계를 기반으로 TCP의 연결을 성립하는 것\n        \n          \n            (그림) 3 Way-Handshake 연결 성립 단계\n\n            \n\n            \n              SYN(synchronization) : 연결 요청 플래그\n              ACK(acknowledgement) : 응답 플래그\n            \n          \n          \n            (그림) Wireshark 패킷 분석 도구에서 요청의 Sequence Number를 조회\n\n            \n          \n          SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN(Random Sequence)을 담아 SYN을 보낸다.\n          SYN + ACK 단계 : 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보낸다.\n          ACK 단계 : 클라이언트는 서버의 ISN + 1한 값인 승인번호를 담아 ACK를 서버에 보낸다.\n        \n      \n    \n  \n  3 Way-Handshake 과정이 끝난 이후 브라우저는 서버에게 데이터를 요청한다. (HTTP Request)\n  서버는 브라우저에게 받은 요청에 응답하여 데이터를 보낸다. (HTTP Response)\n\n\nConstruction - 가져온 HTML, CSS를 Parsing하고 합쳐진 하나의 Tree를 생성하는 단계\n\n\n  서버로 부터 받은 데이터를 출력하기 위해 해당 데이터를 W3C 명세에 따라 해석한다. (Parsing)\n    \n      W3C (World Wide Web Consortium) : 웹의 창시자 팀 버너스리를 중심으로 설립된 웹 표준화 기구, 웹에서 사용되는 HTML, SOAP, XML 등의 표준을 개발한다.\n    \n  \n  브라우저의 렌더링 엔진은 HTML을 Parsing해서 DOM Tree를 생성한다.\n    \n      \n        (그림) DOM Tree &amp;amp; CSSOM Tree &amp;amp; Render Tree\n\n        \n      \n      \n        DOM Tree(Document Object Model Tree) : HTML 문서를 태그나 속성의 계층 구조(트리 구조)로 간주하여 참조하는 개념, 웹 문서를 node 구조의 tree 형태로 표시한다. 웹 브라우저는 DOM을 사용하기 때문에 자바스크립트와 CSS를 사용해서 상호작용이 가능하다.\n      \n    \n  \n  HTML을 Parsing하는 과정에서 렌더링 엔진이 스타일 태그(style)를 만난다면 HTML Parsing 작업을 중지하고, CSS Parsing 작업을 시작하여 CSSOM Tree를 생성한다.\n    \n      CSSOM Tree(CSS Object Model Tree) : HTML 문서를 DOM Tree로 만든 것처럼, CSS도 브라우저가 이해하고 처리할 수 있도록 변환해서 만든 계층 구조\n    \n  \n  CSS Parsing을 종료하고 HTML Parsing이 중단된 지점부터 다시 Parsing을 진행한다. 그러다가 스크립트 태그(script)를 만나면 다시 HTML Parsing을 중단하고 자바스크립트 엔진에게 제어 권한을 넘긴다.\n  자바스크립트 엔진은 코드를 해석하여 AST를 생성한 후 실행한다.\n    \n      \n        (그림) 자바스크립트 코드와 해당 코드를 바탕으로 생성된 AST\n\n        \n      \n      \n        AST(Abstract Syntax Tree) 추상 구문 트리 : 각 노드는 소스코드에서 발생되는 구조를 나타내고, 소스코드를 문법에 맞게 노드로 쪼개서 만든 트리이다. 추상적이라는 의미는 실제 구문에서 나타나는 세세한 정보를 나타내지 않는다는 것을 의미한다.\n      \n    \n  \n  다음으로 중단되었던 HTML Parsing 작업을 완료한다.\n  \n    앞서 만든 DOM Tree와 CSSOM Tree를 합쳐서 Render Tree를 생성한다.\n\n    \n  \n\n\nOperation - 시각화 단계 (layout, paint, composition)\n\n\n  이후 렌더링 엔진은 Layout 작업을 시작하는데 이 작업은 Render Tree의 노드들을 화면의 올바른 위치에 표시하는 것을 의미한다. (layout)\n  UI Backend가 Render Tree의 노드들을 돌면서 UI를 그린다. (paint)\n  노드들의 레이어를 순서대로 구성한다. z-index가 낮은 요소를 먼저 놓고, 그 다음 높은 요소를 놓는다. (composition)\n    \n      z-index : CSS 스타일 코드 중, 창을 순서대로 배치하는 스타일\n    \n  \n\n\n\n  “Better UX” 좀 더 나은 사용자 경험\n\n  이러한 Parsing과 배치(Layout), UI를 paint 하는 과정은 브라우저가 사용자에게 더 빠르게 화면을 출력해주기 위해 서버로부터 데이터의 일부를 받고 나서 화면에 표시하고 또 데이터를 받게 되면 화면에 표시하는 것을 반복한다.\n\n  이 때문에 웹 페이지의 화면은 한 번에 렌더링 되지 않고, 부분적으로 렌더링 되는 현상이 나타나는 것이다.\n\n\n\n  최종적으로 웹의 사용자에게 결과 화면을 출력한다.\n\n\n\n\n이론을 통한 렌더링 최적화 🧐\n\n&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;\n\n\n여담으로 script 태그를 head가 아닌 body의 끝에 삽입하거나 defer 옵션을 사용하라는 말을 한 번쯤은 들어봤을 것이다.\n\nNHN Cloud 에서 발표한 ‘[2018] 프런트엔드 성능 최적화’ 라는 영상이 있는데,\n\nscript 태그의 삽입 위치를 통해서도 렌더링 최적화를 경험할 수 있는 부분이다.\n\n\n\n자료 URL : https://www.youtube.com/watch?v=G1IWq2blu8c&amp;amp;t=970s\n\n이 부분은 브라우저 렌더링 과정을 살펴보면 이해할 수 있는 부분인데,\n\n결론부터 말하면 HTML을 Parsing하는 과정에서 script 태그를 만나 parsing을 중단하고 AST를 생성하고 실행하는 과정이 있기 때문에 스크립트 삽입 위치에 따라 렌더링 시간이 달라진다는 것이다.\n\nhead 에 스크립트를 배치할 경우\n\nhead에 스크립트를 포함할 경우 parsing을 멈추고, JS 파일을 받아오고 실행한 뒤 다시 HTML을 parsing 하는 과정을 진행할텐데..\n\nJavascript 크기가 클 경우 렌더링이 너무 오래걸려서 사용자가 페이지를 보기까지 많은 시간이 소요될 것이다..\n\n그러므로 head 태그 안에 스크립트 파일을 배치하는 것은 좋은 방법이라고 볼 수 없다.\n\nbody 에 스크립트를 배치할 경우\n\nbody 하단에 스크립트를 배치할 경우 HTML parsing을 먼저 진행하고 JS파일을 받아와 실행하게 된다.\n\nbody에 삽입할 경우 화면 렌더링에 head 보다 좀 더 효과적일 수 있으나, Javascript가 포함된 콘텐츠를 보기 위해서는 오래 걸릴 것이다.\n\nasync 속성 사용\n\n&amp;lt;script async src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;\n\n\nasync 속성은 head태그 안에 스크립트 태그를 배치하고 async 속성과 함께 사용하게 된다.\n\nasync 속성은 파싱과 Javascript 불러오기를 병렬적으로 진행하기 때문에 기존 방법들보다는 다운로드 시간이 절약되어 효율적이긴 하지만, 결국 JS를 실행하는 단계에서 HTML Parsing이 중단되기 때문에 의존성이 있는 페이지라면 문제가 될 수 있으므로 유의해서 사용해야 하는 속성이다.\n\n\n\ndefer 속성 사용\n\n&amp;lt;script defer src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;\n\n\ndefer 속성은 async 속성과 마찬가지로 head에 스크립트 태그를 배치하고 defer 속성과 함께 사용하게 된다.\n\n병렬적으로 파싱과 Javascript 불러오기를 진행하게 되고, 파싱이 모두 끝나면 Javascript를 실행한다.\n\n병렬적으로 진행되기 때문에 다운로드 시간도 절약되고 async 속성과 다르게 파싱하는 도중에 Javscript 파일을 모두 다운 받고, 파싱이 끝난 후 순서대로 파일을 실행하기 때문에 원하는 방향대로 스크립트를 실행할 수 있다.\n\n결론적으로 외부 스크립트를 다운받아 불러와야할 경우에는 defer 속성을 사용하는 것이 최선이라고 생각할 수 있다.\n"
} ,
  
  {
    "title"    : "Javascript Test - Jest",
    "category" : "",
    "tags"     : " React, Javascript, Typescript, Test, Jest",
    "url"      : "/syntax/2023/09/13/Test-jest-learn.html",
    "date"     : "September 13, 2023",
    "excerpt"  : "Jest 란?\n\n\n  Facebook에서 만든 테스트 도구이다.\n  zero config 철학을 가지고 있기 때문에 별도의 설정 없이 빠르게 Test Case를 작성할 수 있다.\n\n\nTest를 위한 프로젝트 세팅 및 설치\n\n\n  나는 github/jest_tutorial 이라는 폴더에 프로젝트를 세팅했다.\n  package.json 세팅을 위해 npm init을 사용하고 jest를 설치한다.\n  jest는 테스트 도구로써 개발에서만 사용할...",
  "content"  : "Jest 란?\n\n\n  Facebook에서 만든 테스트 도구이다.\n  zero config 철학을 가지고 있기 때문에 별도의 설정 없이 빠르게 Test Case를 작성할 수 있다.\n\n\nTest를 위한 프로젝트 세팅 및 설치\n\n\n  나는 github/jest_tutorial 이라는 폴더에 프로젝트를 세팅했다.\n  package.json 세팅을 위해 npm init을 사용하고 jest를 설치한다.\n  jest는 테스트 도구로써 개발에서만 사용할 것이기 때문에 ‘devDependencies’ 에 추가한다.\n\n\nnpm init\n\nnpm install jest --save-dev\n\n\npackage.json\n\n{\n  &quot;name&quot;: &quot;jest_tutorial&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;jest&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: {\n    &quot;jest&quot;: &quot;^29.7.0&quot;\n  }\n}\n\n\n\n  테스트 케이스를 작성할 파일의 경우 ‘test.js’로 끝나거나, ‘tests’ 폴더에 있는 파일들은 자동으로 인식한다. 만약 직접 선택한 파일만 test하고 싶다면 npm test 뒤에 파일 명 혹은 경로를 입력하면 된다.\n\n\n\n함수를 모아두고 테스트하기 위한 파일\n\nfn.js\n\nconst fn = {\n    add : (num1, num2) =&amp;gt; num1 + num2,\n    makeUser : (name, age) =&amp;gt; ({name, age, gender : undefined}),\n    throwErr : () =&amp;gt; {\n        throw new Error(&quot;xx&quot;);\n    },\n    getName: (callback) =&amp;gt; {\n        const name = &quot;Mike&quot;;\n\n        setTimeout(() =&amp;gt; {\n            callback(name);\n        }, 3000);\n    },\n    getAge: () =&amp;gt; {\n        const age = 30;\n\n        return new Promise((res, rej) =&amp;gt; {\n            setTimeout(() =&amp;gt; {res(age)}, 3000);\n        })\n    },\n    getAgeError: () =&amp;gt; {\n        const age = 30;\n\n        return new Promise((res, rej) =&amp;gt; {\n            setTimeout(() =&amp;gt; {\n                rej(&#39;error&#39;)\n            }, 3000)\n        })\n    }\n}\n\nmodule.exports = fn;\n\n\n만들어둔 함수를 테스트 하기 위한 파일\n\nfn.test.js\n\nconst fn = require(&#39;./fn&#39;);\n\ntest(&#39;1은 1이다.&#39;, () =&amp;gt; {\n    //expect : 검증할 값\n    //toBe : 기대 값\n    expect(1).toBe(1);\n})\n\ntest(&#39;2 더하기 3은 5다.&#39;, () =&amp;gt; {\n    expect(fn.add(2, 3)).toBe(5);\n});\n\ntest(&#39;2 더하기 3은 5다.&#39;, () =&amp;gt; {\n    expect(fn.add(2, 3)).toEqual(5);\n});\n\ntest(&#39;3 더하기 3은 5가 아니다.&#39;, () =&amp;gt; {\n    expect(fn.add(3, 3)).not.toBe(5);\n})\n\n// (1) 객체나 배열은 재귀적으로 돌면서 값을 확인해야 하기 때문에 toEqual을 사용해야한다.\n// 보다 엄격하게 검사하려면 toStrictEqual을 사용하는게 좋다.\ntest(&#39;이름과 나이를 전달받아서 객체를 반환해줘&#39;, () =&amp;gt; {\n    expect(fn.makeUser(&#39;Mike&#39;, 30)).toEqual(\n        {\n            name : &#39;Mike&#39;,\n            age : 30,\n        }\n    );\n})\n\n// (2) 객체나 배열은 재귀적으로 돌면서 값을 확인해야 하기 때문에 toEqual을 사용해야한다.\n// 보다 엄격하게 검사하려면 toStrictEqual을 사용하는게 좋다.\ntest(&#39;이름과 나이를 전달받아서 객체를 반환해줘&#39;, () =&amp;gt; {\n    \n    expect(fn.makeUser(&#39;Mike&#39;, 30)).toStrictEqual(\n        {\n            name : &#39;Mike&#39;,\n            age : 30,\n        }\n    );\n})\n\ntest(&quot;null은 null이다.&quot;, () =&amp;gt; {\n    expect(null).toBeNull();\n})\n\ntest(&quot;0은 false 이다.&quot;, () =&amp;gt; {\n    expect(fn.add(1, -1)).toBeFalsy();\n})\n\ntest(&quot;0은 false 이다.&quot;, () =&amp;gt; {\n    expect(fn.add(&quot;hello&quot;, &quot;world&quot;)).toBeFalsy();\n})\n\ntest(&quot;비어있지 않은 문자열은 true 이다.&quot;, () =&amp;gt; {\n    expect(fn.add(&quot;hello&quot;, &quot;world&quot;)).toBeTruthy();\n})\n\ntest(&quot;ID는 10자 이하여야 한다.&quot;, () =&amp;gt; {\n    const id = &quot;THE_BLACK&quot;;\n    expect(id.length).toBeLessThanOrEqual(10);\n})\n\ntest(&quot;비밀번호는 4자리여야 한다.&quot;, () =&amp;gt; {\n    const password = &#39;3414&#39;;\n    expect(password.length).toBe(4);\n})\n\ntest(&quot;비밀번호는 4자리여야 한다.&quot;, () =&amp;gt; {\n    const password = &#39;3414&#39;;\n    expect(password.length).toEqual(4);\n})\n\n// 이진법을 이용한 계산으로 몇몇 프로그래밍 언어들은 소수점을 정확하게 표현하지 못하기 때문에 무한소수로 출력되는 경우가 있다.\n// 그러므로 소수점을 활용한 계산에서는 toBeCloseTo를 사용해서 test하는 것이 적절하다.\ntest(&#39;0.1 더하기 0.2는 0.3이다.&#39;, () =&amp;gt; {\n    expect(fn.add(0.1, 0.2)).toBeCloseTo(0.3);\n})\n\ntest(&quot;Hello World 에 a 라는 글자가 있는가 ? &quot;, () =&amp;gt; {\n    expect(&#39;Hello World&#39;).toMatch(/H/i);\n})\n\ntest(&quot;유저 리스트에 Mike가 있는가?&quot;, () =&amp;gt; {\n    const user = &quot;Mike&quot;;\n    const userList = [&quot;Tom&quot;, &quot;Mike&quot;, &quot;Kai&quot;];\n\n    expect(userList).toContain(user);\n})\n\ntest(&quot;에러가 나는가?&quot;, () =&amp;gt; {\n    expect(() =&amp;gt; fn.throwErr()).toThrow(&#39;xx&#39;);\n})\n\n//비동기 함수 테스트를 위해서는 test에 전달되는 callback 함수에 done을 전달해주면 된다.\n//jest는 끝에 코드까지 도달하면 종료되기 때문에 done을 전달하지 않으면 제대로된 테스트가 진행되지 않는다.\ntest(&quot;3초 후에 받아온 이름은 Mike&quot;, (done) =&amp;gt; {\n    function callback(name){\n        try {\n            expect(name).toBe(&quot;Mike&quot;);\n            done();\n        } catch (error) {\n            done();\n        }\n    }\n\n    fn.getName(callback)\n})\n\n// Promise 를 테스트 할 경우\n// Promise 를 사용하면 해당 코드를 return 해주어야 한다 그렇지 않으면 코드가 실행되고 바로 종료되므로 제대로된 테스트가 진행되지 않는다.\n// 좀더 간단하게 사용하고 싶다면 Matcher를 사용하면된다 (resolves, rejects)\ntest(&quot;3초 후에 받아온 나이는 30&quot;, () =&amp;gt; {\n    return expect(fn.getAge()).resolves.toBe(30);\n\n    // return fn.getAge().then(age =&amp;gt; {\n    //     expect(age).toBe(30);\n    // })\n})\n\n// Promise에서 reject를 테스트할 경우\ntest(&quot;3초 후애 에러를 리턴&quot;, () =&amp;gt; {\n    return expect(fn.getAgeError()).rejects.toMatch(&#39;error&#39;);\n})\n\n\nnpm test 결과\n\n➜  jest_tutorial npm test\n\n&amp;gt; jest_tutorial@1.0.0 test\n&amp;gt; jest\n\n FAIL  ./fn.test.js (9.261 s)\n  ✓ 1은 1이다. (1 ms)\n  ✓ 2 더하기 3은 5다.\n  ✓ 2 더하기 3은 5다. (1 ms)\n  ✓ 3 더하기 3은 5가 아니다.\n  ✓ 이름과 나이를 전달받아서 객체를 반환해줘\n  ✕ 이름과 나이를 전달받아서 객체를 반환해줘 (4 ms)\n  ✓ null은 null이다. (1 ms)\n  ✓ 0은 false 이다.\n  ✕ 0은 false 이다.\n  ✓ 비어있지 않은 문자열은 true 이다.\n  ✓ ID는 10자 이하여야 한다.\n  ✓ 비밀번호는 4자리여야 한다.\n  ✓ 비밀번호는 4자리여야 한다.\n  ✓ 0.1 더하기 0.2는 0.3이다. (1 ms)\n  ✓ Hello World 에 a 라는 글자가 있는가 ?\n  ✓ 유저 리스트에 Mike가 있는가?\n  ✓ 에러가 나는가? (2 ms)\n  ✓ 3초 후에 받아온 이름은 Mike (3002 ms)\n  ✓ 3초 후에 받아온 나이는 30 (3002 ms)\n  ✓ 3초 후애 에러를 리턴 (3001 ms)\n\n  ● 이름과 나이를 전달받아서 객체를 반환해줘\n\n    expect(received).toStrictEqual(expected) // deep equality\n\n    - Expected  - 0\n    + Received  + 1\n\n      Object {\n        &quot;age&quot;: 30,\n    +   &quot;gender&quot;: undefined,\n        &quot;name&quot;: &quot;Mike&quot;,\n      }\n\n      34 | test(&#39;이름과 나이를 전달받아서 객체를 반환해줘&#39;, () =&amp;gt; {\n      35 |\n    &amp;gt; 36 |     expect(fn.makeUser(&#39;Mike&#39;, 30)).toStrictEqual(\n         |                                     ^\n      37 |         {\n      38 |             name : &#39;Mike&#39;,\n      39 |             age : 30,\n\n      at Object.toStrictEqual (fn.test.js:36:37)\n\n  ● 0은 false 이다.\n\n    expect(received).toBeFalsy()\n\n    Received: &quot;helloworld&quot;\n\n      51 |\n      52 | test(&quot;0은 false 이다.&quot;, () =&amp;gt; {\n    &amp;gt; 53 |     expect(fn.add(&quot;hello&quot;, &quot;world&quot;)).toBeFalsy();\n         |                                      ^\n      54 | })\n      55 |\n      56 | test(&quot;비어있지 않은 문자열은 true 이다.&quot;, () =&amp;gt; {\n\n      at Object.toBeFalsy (fn.test.js:53:38)\n\nTest Suites: 1 failed, 1 total\nTests:       2 failed, 18 passed, 20 total\nSnapshots:   0 total\nTime:        9.288 s\nRan all test suites.\n➜  jest_tutorial\n\n\n\n  Jest에는 다양한 Matcher가 존재하고 Test할 함수나 기능에 따라 유용하게 사용할 수 있기 때문에 공식 Docs를 보면서 필요한 Matcher를 찾아보며 테스트를 진행하면 좋을거 같다.\n\n\n\nJest Matchers :\n\nUsing Matchers · Jest\n"
} ,
  
  {
    "title"    : "React에서 Skeleton Loading 만들기",
    "category" : "",
    "tags"     : " React, Typescript",
    "url"      : "/syntax/2023/07/19/Skeleton-loading.html",
    "date"     : "July 19, 2023",
    "excerpt"  : "\n\n진행중인 팀 프로젝트에 여러 컨텐츠가 나오게 되면서\n\nUX적인 부분을 개선하기 위해 디자이너님과 로딩에 대해서 고민을 하다가 스켈레톤 로딩을 만들게 되었다.\n\nSkeleton Loading 이란 ?\n\n화면의 뼈대와 같은 느낌을 주는 로딩 UI를 사용해서 데이터를 불러오는 중일 때 사용하는 UI/UX 기법이다.\n\n데이터 로딩 중 데이터가 불러와진 상태를 미리 알 수 있어서 유저에게 있어서는 예측이 가능하다는 장점과\n\n불러온 이후 레이아웃...",
  "content"  : "\n\n진행중인 팀 프로젝트에 여러 컨텐츠가 나오게 되면서\n\nUX적인 부분을 개선하기 위해 디자이너님과 로딩에 대해서 고민을 하다가 스켈레톤 로딩을 만들게 되었다.\n\nSkeleton Loading 이란 ?\n\n화면의 뼈대와 같은 느낌을 주는 로딩 UI를 사용해서 데이터를 불러오는 중일 때 사용하는 UI/UX 기법이다.\n\n데이터 로딩 중 데이터가 불러와진 상태를 미리 알 수 있어서 유저에게 있어서는 예측이 가능하다는 장점과\n\n불러온 이후 레이아웃이 동일하여 레이아웃이 망가지지 않는 장점이 있다.\n\n조사를 진행하며 라이브러리를 사용하시는 분들도 많고 따로 구현하시는 분들도 많아\n\n본인도 따로 구현하는 방법으로 진행하였다.\n\nSkeletonLoading.tsx\n\nimport React from &#39;react&#39;;\nimport styles from &quot;./SkeletonLoading.module.css&quot;;\n\nfunction SkeletonLoading({type}: {type: string}){\n    let classes\n\n    switch (type) {\n        case &#39;title&#39;:\n            classes = styles.title;\n            break;\n        case &#39;text&#39;:\n            classes = styles.text;\n            break;\n        case &#39;avatar&#39;:\n            classes = styles.avatar;\n            break;\n        case &#39;thumbnail&#39;:\n            classes = styles.thumbnail;\n            break;\n    }\n\n    return (\n        &amp;lt;div className={`${styles.skeleton} ${classes}`}&amp;gt;&amp;lt;/div&amp;gt;\n    )\n}\n\nexport default SkeletonLoading;\n\n\nSkeletonLoading.module.css\n\n.skeleton {\n    background: #ddd;\n    border-radius: 4px;\n}\n.skeleton.text {\n    width : 100%;\n    height : 16px;\n}\n\n.skeleton.title {\n    width: 50%;\n    height: 20px;\n}\n\n.skeleton.avatar{\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n}\n\n.skeleton.thumbnail {\n    width: 100px;\n    height : 100px;\n}\n\n\nSkeletonLoading 의 뼈대가 되는 컴포넌트를 만들어서 string 타입으로 type을 받아서 여러 스타일을 사용할 수 있게 만들어주고\n\nSkeletonLoading 컴포넌트를 활용해서 로딩 UI가 필요한 컴포넌트 레이아웃과 비슷하게 배치하여 새로운 컴포넌트를 만들어준다.\n\n\n\nskeleton-componenet/index.ts\n\nimport SkeletonWorkbook from &quot;./SkeletonWorkbook&quot;;\nimport SkeletonTopViewWorkbook from &#39;./SkeletonTopViewWorkbook&#39;;\n\nexport default {\n    SkeletonWorkbook,\n    SkeletonTopViewWorkbook,\n}\n\n\nSkeletonWorkbook.tsx\n\nimport React from &#39;react&#39;;\nimport styles from &#39;./SkeletonWorkbook.module.css&#39;;\nimport SkeletonLoading from &#39;../skeleton-root/SkeletonLoading&#39;;\n\nfunction SkeletonWorkbook(){\n    return(\n        &amp;lt;div className={styles.skeleton_workbook_root}&amp;gt;\n            &amp;lt;div className={styles.title_container}&amp;gt;\n                &amp;lt;SkeletonLoading type=&quot;title&quot; /&amp;gt;\n            &amp;lt;/div&amp;gt;\n            &amp;lt;div className={styles.body_container}&amp;gt;\n                &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n                &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n                &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n            &amp;lt;/div&amp;gt;\n        &amp;lt;/div&amp;gt;\n    )\n}\n\nexport default SkeletonWorkbook;\n\n\nSkeletonTopViewWorkbook.tsx\n\nimport React from &#39;react&#39;;\nimport styles from &#39;./SkeletonTopViewWorkbook.module.css&#39;\nimport SkeletonLoading from &#39;../skeleton-root/SkeletonLoading&#39;;\n\nfunction SkeletonTopViewWorkbook(){\n    return(\n        &amp;lt;div className={styles.skeleton_topview_root}&amp;gt;\n            &amp;lt;div&amp;gt;\n                &amp;lt;SkeletonLoading type=&quot;title&quot; /&amp;gt;\n            &amp;lt;/div&amp;gt;\n            &amp;lt;div className={styles.body_container}&amp;gt;\n                &amp;lt;div className={styles.content_container}&amp;gt;\n                    &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n                    &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n                    &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n                &amp;lt;/div&amp;gt;\n                &amp;lt;div&amp;gt;\n                    &amp;lt;SkeletonLoading type=&quot;text&quot; /&amp;gt;\n                &amp;lt;/div&amp;gt;\n            &amp;lt;/div&amp;gt;\n        &amp;lt;/div&amp;gt;\n    )\n}\n\nexport default SkeletonTopViewWorkbook;\n\n\n동적인 느낌을 주기 위해 조사를 진행하여 보니 컴포넌트와 CSS를 하나 더 생성하여 처리하는 방법이 있어서 이를 활용해보았다.\n\n\n\nShimmer.tsx\n\nimport React from &#39;react&#39;;\nimport styles from &#39;./Shimmer.module.css&#39;;\n\nfunction Shimmer(){\n    return (\n    &amp;lt;div className={styles.shimmer_wrapper}&amp;gt;\n      &amp;lt;div className={styles.shimmer}&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;/div&amp;gt;\n    )\n}\n\nexport default Shimmer;\n\n\nShimmer.module.css\n\n.shimmer_wrapper {\n    position : absolute;\n    top: 0;\n    left : 0;\n    width : 100%;\n    height : 100%;\n    animation: loading_animation 2.5s infinite;\n}\n\n.shimmer {\n    width : 50%;\n    height: 100%;\n    background-color: rgba(255,255,255,0.2);\n    transform: skewX(-20deg);\n    box-shadow: 0 0 30px 30px rgba(255,255,255,0.05);\n}\n\n@keyframes loading_animation{\n    0% {\n        transform: translateX(-150%);\n    }\n    50% {\n        transform: translateX(-60%);\n    }\n    100% {\n        transform: translate(150%);\n    }\n}\n\n\nReact Query의 isLoading을 활용해서 이렇게 사용할 수 있다.\n\n\n"
} ,
  
  {
    "title"    : "아토믹 디자인 패턴 (Atomic Design Pattern) 공부 및 적용기 #1",
    "category" : "",
    "tags"     : " React, DesignPattern, Typescript",
    "url"      : "/syntax/2023/05/01/AtomicDesignPattern01.html",
    "date"     : "May 1, 2023",
    "excerpt"  : "아토믹 디자인 패턴이란?\n\n\n\n\n  좀 더 효과적인 컴포넌트를 구성하기 위한 방법론 중 하나이다.\n  일관되고 견고하고 재사용이 가능한 디자인 시스템을 만드는데 도움을 준다.\n  페이지를 디자인 하는 것이 아닌 컴포넌트들의 시스템을 디자인 하는 것이다.\n\n\n장점과 단점\n\n장점\n\n\n  한 번만 구현해 놓고 계속 가져다 쓸 수 있는 코드가 생긴다.\n  Storybook을 활용해서 컴포넌트들을 더 효과적으로 정리할 수 있다.\n  어플리케이션의 ...",
  "content"  : "아토믹 디자인 패턴이란?\n\n\n\n\n  좀 더 효과적인 컴포넌트를 구성하기 위한 방법론 중 하나이다.\n  일관되고 견고하고 재사용이 가능한 디자인 시스템을 만드는데 도움을 준다.\n  페이지를 디자인 하는 것이 아닌 컴포넌트들의 시스템을 디자인 하는 것이다.\n\n\n장점과 단점\n\n장점\n\n\n  한 번만 구현해 놓고 계속 가져다 쓸 수 있는 코드가 생긴다.\n  Storybook을 활용해서 컴포넌트들을 더 효과적으로 정리할 수 있다.\n  어플리케이션의 복잡함을 해결해준다.\n  뷰와 비즈니스 로직의 분리로 프로젝트가 확장될 때 코드에서 문제를 디버깅하기 쉽다.\n\n\n단점\n\n\n  단기적으로 봤을 때 개발 시간이 오래걸린다.\n\n\n\n\n아토믹 디자인 패턴의 구성\n\nAtom (원자)\n\n\n\n&amp;lt; label, input, button atom &amp;gt;\n\n\n  가장 작은 컴포넌트의 단위이다.\n  원자는 어떠한 context가 주어져도 해당하는 컴포넌트가 생성될 수 있어야 한다.\n  다양한 state(상태)를 가지고 있어야하며 추상적이지만 최대한 포용할 수 있게 설계 되어야 한다.\n  원자는 margin이나 위치 값을 가지지 않는다.\n  label, input, button과 같은 기본 HTML element 태그 혹은 글꼴, 애니메이션, 컬러 팔레트, 레이아웃과 같이 추상적인 요소도 포함될 수 있다.\n\n\nMolecule(분자)\n\n\n\n&amp;lt; search from molecule &amp;gt;\n\n\n  Atom(원자)을 두 개 이상 조합하면 Molecule(분자)가 된다.\n  분자는 분자만의 프로퍼티를 가지고 있을 수 있고, 이를 활용해 원자에 기능을 만들어 줄 수 있다.\n  분자가 원자의 위치값을 지정하기도 한다.\n\n\nOrganism(유기체)\n\n\n\n&amp;lt; haeder organism &amp;gt;\n\n\n  Organism(유기체)은 분자를 엮어 만들어서 생성되고 때로는 분자가 되지 않은 원자가 엮이기도 한다.\n  유기체가 완성되면 컴포넌트가 최종 모습을 가지게 된다.\n  유기체는 분자와 원자의 위치 값을 조정한다.\n  atom, molecule에 비해 좀 더 구체적으로 표현되고 컨텍스트를 가지기 때문에 상대적으로 재사용성이 낮아지는 특성을 가진다.\n\n\nTemplate (Layout)\n\n\n\n&amp;lt; layout이 적용된 molecule과 organism으로 구성된 template &amp;gt;\n\n\n  템플릿은 만들어진 유기체와 컴포넌트의 position을 정해주는 역할을 한다.\n  템플릿 파일은 주로 페이지를 구성하기 위해 서로 꿰매어진 유기체 그룹으로 구성되며, 이 부분에서 디자인을 확인하고 레이아웃이 실제로 구동하는지 볼 수 있다.\n  템플릿에는 styling이나 color가 들어가지 않는다.\n  템플릿의 역할은 페이지의 그리드를 정해주는 역할 뿐이다.\n  실제 컴포넌트를 레이아웃에 배치하고 구조를 잡는 와이어 프레임이다.\n  실제 콘텐츠가 없는 page 수준의 스켈레톤이라고 정의할 수 있다.\n\n\nPage\n\n\n\n&amp;lt; 여러가지 콘텐츠를 template에 적용하여 최종 UI를 보여주는 page &amp;gt;\n\n\n  page는 유저가 볼 수 있는 실제 콘텐츠를 담는다.\n  template의 인스턴스라고 할 수 있다.\n  template을 이용해서 각 그리드에 컴포넌트를 그려서 디스플레이 한다.\n\n\n\n\n어떻게 프로젝트 구조를 잡을까 ?\n\n\n  해당 소스는 Atomic Design Pattern과 React Recoil을 통한 어플리케이션 작성을 공부하기 위해 작성중인 코드이다.\n\n\n\n구조는 다른 분들의 소스를 참고하여 구성해보았다.\n\n├── Router.tsx\n├── components\n│   ├── Atoms\n│   │   ├── Button.tsx\n│   │   ├── Div.tsx\n│   │   ├── Input.tsx\n│   │   ├── Span.tsx\n│   │   └── index.ts\n│   ├── Molecules\n│   │   ├── TodoCreateInput.tsx\n│   │   └── index.ts\n│   ├── Organisms\n│   │   ├── TodoForm.tsx\n│   │   └── index.ts\n│   ├── Pages\n│   │   ├── Main.tsx\n│   │   └── index.ts\n│   └── Template\n│       └── index.ts\n├── index.tsx\n├── react-app-env.d.ts\n├── reportWebVitals.ts\n├── setupTests.ts\n├── state\n│   └── index.ts\n└── test\n    └── Pages\n        └── Main.test.tsx\n\n\n\n  src 디렉토리 밑에 components 디렉토리를 만들고 역할 별로 디렉토리를 나눈 후 index에서 관리할 수 있게끔 구조를 잡아보았다.\n\n\n‘component/Atoms/Input.tsx’\n\n\n  또한 styled 컴포넌트를 적극 활용하여 스타일 코드를 props로 내려받아 사용할 수 있다.\n\n\n\n  개인적으로 구조를 잡고 구성하는 것에는 시간이 많이 걸리고 고민이 많지만 정말 깔끔한 코드를 작성할 수 있는 것 같음.\n\n\n\nimport styled from &#39;styled-components&#39;;\n\nconst Input = styled.input&amp;lt;React.CSSProperties &amp;amp; {\n    placeholderColor?: string;\n} \n&amp;gt;`\n    -webkit-appearance: none;\n    -moz-appearance: none;\n    appearance: none;\n\n    margin: ${({ margin }) =&amp;gt; margin};\n    padding: ${({ padding }) =&amp;gt; padding || &#39;8px&#39;};\n    line-height: ${({ lineHeight }) =&amp;gt; lineHeight};\n    height: ${({ height }) =&amp;gt; height || &#39;40px&#39;};\n    width: ${({ width }) =&amp;gt; width || &#39;100%&#39;};\n    border: ${({ border }) =&amp;gt; border || &#39;1px solid #e8e8e8&#39;};\n    box-sizing: border-box;\n    border-radius: ${({ borderRadius }) =&amp;gt; borderRadius || &#39;8px&#39;};\n    background-color: ${({backgroundColor}) =&amp;gt; backgroundColor};\n    font-size: ${({ fontSize }) =&amp;gt; fontSize || &#39;16px&#39;};\n\n    :focus {\n        outline: none;\n    }\n    ::placeholder {\n        color: ${({placeholderColor}) =&amp;gt; placeholderColor};\n    }\n`\n\nexport default Input;\n\n\n이렇게 구성한 Atom Component를 Molecule Component에서 좀 더 복잡한 구조의 컴포넌트로 만들어서 재사용할 수 있다.\n\n‘component/Molecules/TodoCreateInput.tsx’\n\nimport React from &#39;react&#39;;\nimport Atoms from &#39;components/Atoms&#39;;\n\nfunction TodoCreateInput(){\n    return(\n        &amp;lt;Atoms.Div display=&#39;flex&#39; gap=&quot;5px&quot;&amp;gt;\n            &amp;lt;Atoms.Input border=&quot;0px&quot; backgroundColor=&quot;#f2f2f2&quot; placeholder=&#39;할 일을 입력해주세요.&#39; placeholderColor=&quot;#cecece&quot;/&amp;gt;\n            &amp;lt;Atoms.Button border=&quot;1px solid #e0e0e0&quot; borderRadius=&quot;8px&quot;&amp;gt;asdasd&amp;lt;/Atoms.Button&amp;gt;\n        &amp;lt;/Atoms.Div&amp;gt;\n    )\n}\n\nexport default TodoCreateInput;\n\n\n더 깔끔하게 해당 디자인 패턴을 사용할 수 있는 방법을 이번 프로젝트를 통해 계속 연구해볼 계획이다.\n\nRecoil도 빨리 공부해서 적용해보고 싶다. 재미있어보임\n\nGithub Source Link : https://github.com/sdf5771/my-todo-app.git\n\n\n\n스터디 참고 자료\n\n카카오 FE 기술블로그 : 카카오엔터테인먼트 FE 기술블로그\n\n유튜브 : Atomic Design Pattern (아토믹 디자인 패턴)\n"
} ,
  
  {
    "title"    : "[Next JS] 학습 01 - 프로젝트 생성 및 개념 공부",
    "category" : "",
    "tags"     : " React, SEO, NextJS",
    "url"      : "/syntax/2023/04/25/Next-js-practice.html",
    "date"     : "April 25, 2023",
    "excerpt"  : "1. next js app 프로젝트 만들기\n\nnpx create-next-app@latest\n\n\n\n\n\n  create-next-app으로 프로젝트를 만들면 여러 옵션을 선택한다.\n    \n      Would you like to use TypeScript with this project? - 타입스크립트 사용 여부를 선택\n      Would you like to use ESLint with this project - ESLint 사용 ...",
  "content"  : "1. next js app 프로젝트 만들기\n\nnpx create-next-app@latest\n\n\n\n\n\n  create-next-app으로 프로젝트를 만들면 여러 옵션을 선택한다.\n    \n      Would you like to use TypeScript with this project? - 타입스크립트 사용 여부를 선택\n      Would you like to use ESLint with this project - ESLint 사용 여부를 선택 (코딩 컨벤션에 위배되는 코드나 안티 패턴을 자동 검출하는 도구)\n      Would you like to use Tailwind CSS with this project? - Tailwind CSS 사용 여부를 선택 (https://fe-developers.kakaoent.com/2022/220303-tailwind-tips/)\n      Would you like to use ‘src/’ directory with this project? - src 폴더에서 관리를 할 것인지 root에서 관리를 할 것인지 선택\n      Would you like to use experimental ‘app/’ directory with this project? - app 디렉토리를 실험적인걸 사용할건지 선택\n      What import alias would you like configured? - import 시 Base 경로를 설정\n    \n  \n\n\n2. Next js에서의 Page\n\nNext js는 React js로 만든 웹사이트와 다르게 라우터를 설정해 줄 필요가 없다 ← Next js와 React js의 차이점이 여기서 나타나게 된다 (프레임워크와 라이브러리의 차이)\n\n\n  pages 디렉토리 내부에 생성한 자바스크립트 파일이 곧 URL의 path가 되며, 해당 컴포넌트는 export default 해야한다.\n  해당 컴포넌트의 이름은 크게 중요하지 않다. URL이 되는 것은 파일명이다.\n\n\n\n\n\n\n\n\n\n  그리고 Next js에는 기본적으로 404 페이지가 제공된다.\n\n\n\n\n3. getServerSideProps\n\n\n  기존 동적으로 렌더링하던 부분을 정적으로 Server Side에서 실행하기 위해 사용할 수 있다.\n\n\n언제 사용해야 하는가?\n\n\n  request time에 반드시 데이터를 fetch해야 하는 페이지를 pre-render해야 하는 경우에만 getServerSideProps를 사용해야 한다.\n  데이터를 pre-render할 필요가 없다면 client side에서 데이터를 가져오는 것을 고려해야 한다.\n  페이지에 자주 업데이트되는 데이터가 포함되어 있고 데이터를 pre-render할 필요가 없는 경우 클라이언트 측에서 데이터를 가져올 수 있다.\n    \n      먼저 데이터가 없는 페이지를 즉시 표시한다.\n      페이지의 일부는 Static Generation을 사용해 pre-render할 수 있다.\n      없는 데이터를 위해 loading 상태를 표시할 수 있다.\n      클라이언트 측에서 데이터를 가져와 준비가 되면 표시한다.\n    \n  \n\n\n해당 접근 방식은 사용자 대시보드 페이지에 적합하다.\n\n\n  대시보드는 사용자 별 비공개 페이지이므로 SEO와 연관이 없다.\n  페이지를 미리 렌더링할 필요가 없다.\n  데이터가 자주 업데이트되므로 요청 시 데이터를 가져와야 한다.\n\n\n*pre-rendering :  HTML을 미리 렌더링하는 것이다. 해당 기능에는 두 가지 방식이 있다.\n\n\n  Static Generation : HTML을 빌드 타임에 생성해 두고 요청시마다 재사용하는 방법\n  Server Side Rendering : 요청 시 마다 Server에서 HTML을 생성해주는 방법\n\n\n사용자에 따라서 브라우저의 JavaScript 사용을 꺼놓거나, 브라우저 버전이 낮아서 리엑트를 실행시키지 못할 경우에도 Next js는 미리 만들어둔 HTML이 있어서 화면에 렌더링 할 수 있다.\n\nimport {useState, useEffect} from &#39;react&#39;;\nimport Seo from &#39;@/components/Seo&#39;\n \nexport default function Home({results}){\n    // const [movies, setMovies] = useState([]);\n    // useEffect(() =&amp;gt; {\n    //     (async () =&amp;gt; {\n    //         const {results} = await (await fetch(&quot;http://localhost:3000/api/movies&quot;)).json();\n    //         setMovies(results)\n    //     })();\n    // },[])\n    return (\n        &amp;lt;div className=&#39;home-container&#39;&amp;gt;\n            &amp;lt;Seo title=&quot;Home&quot; /&amp;gt;\n            &amp;lt;div className=&quot;movie-container&quot;&amp;gt;\n            {results ? results.map((movie) =&amp;gt; (\n                &amp;lt;div key={movie.id}&amp;gt;\n                    &amp;lt;img src={`https://image.tmdb.org/t/p/w500/${movie.poster_path}`} /&amp;gt;\n                    &amp;lt;h4&amp;gt;{movie.original_title}&amp;lt;/h4&amp;gt;\n                &amp;lt;/div&amp;gt;\n            )) : &amp;lt;h4&amp;gt;...now loading&amp;lt;/h4&amp;gt;}\n            &amp;lt;/div&amp;gt;\n            &amp;lt;style jsx&amp;gt;{\n                `\n                    .movie-container{\n                        margin-top: 30px;\n                        width: 100%;\n                        display: flex;\n                        justify-content: center;\n                        gap: 30px;\n                        flex-wrap: wrap;   \n                    }\n                    .movie-container &amp;gt; div &amp;gt; img{\n                        max-width: 100%;\n                        border-radius: 12px;\n                        transition: transform 0.2s ease-in-out;\n                        box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 12px;\n                    }\n                    .movie-container &amp;gt; div:hover &amp;gt; img{\n                        transform: scale(1.05) ;\n                    }\n                    .movie-container &amp;gt; div {\n                        display: flex;\n                        flex-direction: column;\n                        padding: 10px;\n                        width: 220px;\n                        overflow: hidden;\n                        cursor: pointer;\n                    }\n                    .movie-container &amp;gt; div &amp;gt; h4{\n                        font-size: 1rem;\n                        text-align: center;\n                        overflow: hidden;\n                        text-overflow: ellipsis;\n                        white-space: nowrap;\n                    }\n                `\n            }\n            &amp;lt;/style&amp;gt;\n        &amp;lt;/div&amp;gt;\n    );\n}\n\nexport async function getServerSideProps(){\n    const {results} = await (await fetch(&quot;http://localhost:3000/api/movies&quot;)).json();\n\n    return {\n        props: {\n            results,\n        }\n    }\n}\n\n\n결과\n\n\n"
} ,
  
  {
    "title"    : "Technical SEO를 위한 동적 메타태그 작성 feat.React Project",
    "category" : "",
    "tags"     : " React, SEO, MetaTag",
    "url"      : "/syntax/2023/04/15/Technical-SEO-meta-tag.html",
    "date"     : "April 15, 2023",
    "excerpt"  : "현재 작업중인 팀 프로젝트에서 SEO를 위한 메타 태그를 작업하며 공부한 것을 기록해본다.\n\nTechnical SEO\n\n테크니컬 SEO는 웹 사이트 검색 순위 향상을 위해서 기술적인 요구 사항을 확인하는 과정이다.\n\n크롤링과 인덱싱, 렌더링 및 웹사이트 구조 등이 포함된다.\n\n구글이나 네이버 같은 검색 사이트에서 내가 운영중인 사이트와 관련 키워드로 검색할 경우\n\n상단에 노출 시켜서 검색을 통한 유입률을 올리고자 하는 작업이며 그러므로 아...",
  "content"  : "현재 작업중인 팀 프로젝트에서 SEO를 위한 메타 태그를 작업하며 공부한 것을 기록해본다.\n\nTechnical SEO\n\n테크니컬 SEO는 웹 사이트 검색 순위 향상을 위해서 기술적인 요구 사항을 확인하는 과정이다.\n\n크롤링과 인덱싱, 렌더링 및 웹사이트 구조 등이 포함된다.\n\n구글이나 네이버 같은 검색 사이트에서 내가 운영중인 사이트와 관련 키워드로 검색할 경우\n\n상단에 노출 시켜서 검색을 통한 유입률을 올리고자 하는 작업이며 그러므로 아주 중요한 작업이다.\n\n현재 내가 작업중인 프로그램은 Qualk라는 프로그램으로 “Google Analytics” 나 여러 자격증을 공부할 수 있는 공간을 만드는 중이다.\n\n내 사이트가 크롤 봇이 좋게 봐주는 사이트로 만들기 위한 작업 중\n\n메타 태그에 관한 작업을 고민한 글을 써본다.\n\n메타 태그 (Meta tag)\n\n웹페이지 자체의 정보를 명시하기 위한 목적으로 사용되는 HTML 태그를 의미한다.\n\n보통 &amp;lt;head&amp;gt; 요소 아래 배치하고 일반 유저가 보는 웹 컨텐츠에는 영향을 주지 않는다.\n\n그럼에도 왜 이것을 중요하게 작업해야 하는가?\n\n검색엔진과 같은 기계들이 웹페이지를 읽어야할 때는 메타 태그의 내용들이 해당 서비스에서 어떻게 표시될지를 결정하는 매우 핵심적인 요소가 된다.\n\n이를 현재 작업중인 React에서 어떻게 동적으로 활용할지 해당 내용을 학습하면서 고민을 해보았다.\n\n\n\n작업 전 해결을 위한 고민\n\n\n  Qualk는 다른 컨텐츠도 많지만 해당 자격증 관련 문제를 제공하기 위한 사이트이다.\n  그러므로 해당 문제마다 다른 키워드에 의해 크롤러에게 노출이 되어야 하므로 각 문제나 URL depth 마다 각각의 동적인 데이터로 작성이 필요하다고 생각하였다.\n  meta tag의 추가, 수정, 삭제가 쉽게 되어야 한다.\n  내가 원하는 곳에서 컴포넌트처럼 불러오고 싶다.\n\n\n\n\n고민과 아이디어를 도출해냈으니 학습 후 작업을 진행하면 된다.\n\nreact-helmet-async\n\n나는 react-helmet-async라는 라이브러리를 사용하여 작업을 진행하였다.\n\nnpm: react-helmet-async\n\n설치 후 DOCS에서 사용 방법을 확인해보니 해당 라이브러리를 사용하기 전\n\n상단 컴포넌트를 Provider로 wrapping 할 필요가 있는 듯 하였다.\n\nHelmetProvider Wrapping\n\nQualk : root/index.tsx\n\nimport React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom/client&#39;;\nimport {BrowserRouter} from &#39;react-router-dom&#39;;\nimport App from &#39;./App&#39;;\nimport store from &#39;store/store&#39;;\nimport {Provider} from &#39;react-redux&#39;;\nimport {HelmetProvider} from &#39;react-helmet-async&#39;;\n\nconst root = ReactDOM.createRoot(\n  document.getElementById(&#39;root&#39;) as HTMLElement\n);\nroot.render(\n    &amp;lt;Provider store={store}&amp;gt;\n        &amp;lt;BrowserRouter&amp;gt;\n            &amp;lt;HelmetProvider&amp;gt;\n                &amp;lt;App /&amp;gt;\n            &amp;lt;/HelmetProvider&amp;gt;\n        &amp;lt;/BrowserRouter&amp;gt;\n    &amp;lt;/Provider&amp;gt;\n);\n\n\n\n  react-helmet-async을 import 후 HelmetProvider를 가져와서 최상단 컴포넌트에 wrapping해주었다. (App 밑에 다양한 컴포넌트에서 해당 기능을 사용할 생각이기 때문)\n\n\nComponent 화\n\n\n\nimport React from &#39;react&#39;;\nimport {Helmet} from &#39;react-helmet-async&#39;;\n\ntype SEOMetaTagPropsType = {\n    title: string;\n    description: string;\n    imgSrc: string;\n    url: string;\n    keywords: string;\n}\n\nconst SEOMetaTag = ({title, description, imgSrc, url, keywords}: SEOMetaTagPropsType) =&amp;gt; {\n    return(\n        &amp;lt;Helmet&amp;gt;\n            &amp;lt;meta name=&quot;type&quot; content=&quot;website&quot; /&amp;gt;\n            &amp;lt;meta name=&quot;title&quot; content={title} /&amp;gt;\n            &amp;lt;meta name=&quot;description&quot; content={description} /&amp;gt;\n            &amp;lt;meta name=&quot;keywords&quot; content={keywords} /&amp;gt;\n            &amp;lt;meta name=&quot;site_name&quot; content={title} /&amp;gt;\n            &amp;lt;meta name=&quot;image&quot; content={imgSrc} /&amp;gt;\n            &amp;lt;meta name=&quot;url&quot; content={url} /&amp;gt;\n\n            &amp;lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&amp;gt;\n            &amp;lt;meta property=&quot;og:title&quot; content={title} /&amp;gt;\n            &amp;lt;meta property=&quot;og:site_name&quot; content={title} /&amp;gt;\n            &amp;lt;meta property=&quot;og:description&quot; content={description} /&amp;gt;\n            &amp;lt;meta property=&quot;og:image&quot; content={imgSrc} /&amp;gt;\n            &amp;lt;meta property=&quot;og:url&quot; content={url} /&amp;gt;\n\n            &amp;lt;meta property=&quot;twitter:type&quot; content=&quot;website&quot; /&amp;gt;\n            &amp;lt;meta property=&quot;twitter:title&quot; content={title} /&amp;gt;\n            &amp;lt;meta property=&quot;twitter:site_name&quot; content={title} /&amp;gt;\n            &amp;lt;meta property=&quot;twitter:description&quot; content={description} /&amp;gt;\n            &amp;lt;meta property=&quot;twitter:image&quot; content={imgSrc} /&amp;gt;\n            &amp;lt;meta property=&quot;twitter:url&quot; content={url} /&amp;gt;\n            &amp;lt;link rel=&quot;canonical&quot; href={url} /&amp;gt;\n            &amp;lt;link rel=&quot;alternate&quot; hrefLang=&quot;ko&quot; href={url} /&amp;gt;\n        &amp;lt;/Helmet&amp;gt;\n    );\n}\n\nexport default SEOMetaTag;\n\n\n\n  위와 같이 react-helmet-async에서 Helmet  을 import 해서 meta tag를 컴포넌트로 만든 후 meta tag 삽입이 필요한 페이지를 담당하는 컴포넌트에서 데이터를 넣고 호출하는 방법을 사용하면 편한 것 같다.\n\n\nSEOMetaTag Component 사용\n\n\n\n나중에 검색 키워드가 회의를 통해 확립되면 해당 부분들을 동적으로 변경해주면 된다.\n\nSEO는 사이트맵도 작업해야하고 URL 구조도 생각 많이해야하고 정말 어렵다..\n"
} ,
  
  {
    "title"    : "[Python]백준 : 10986 나머지 합",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/04/13/Python-Prefix-sum-reminder.html",
    "date"     : "April 13, 2023",
    "excerpt"  : "백준 : 10986 나머지 합\n\n문제\n\n수 N개 A1, A2, …, AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.\n\n즉, Ai + … + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.\n\n입력\n\n첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 106, 2 ≤ M ≤ 103)\n\n둘째 줄에 N개의 수 A1, A2, …, AN이 주...",
  "content"  : "백준 : 10986 나머지 합\n\n문제\n\n수 N개 A1, A2, …, AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.\n\n즉, Ai + … + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.\n\n입력\n\n첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 106, 2 ≤ M ≤ 103)\n\n둘째 줄에 N개의 수 A1, A2, …, AN이 주어진다. (0 ≤ Ai ≤ 109)\n\n출력\n\n첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.\n\n예제 입력 1\n\n5 3\n1 2 3 1 2\n\n\n\n예제 출력 1\n\n7\n\n\n\n출처\n\n\n  문제를 만든 사람: baekjoon\n  데이터를 추가한 사람: cs71107\n\n\n알고리즘 분류\n\n\n  수학\n  누적 합\n\n\n\n\n풀이\n\nimport sys\n# input값의 크기가 크므로 input 함수에 sys.stdin.readline을 override\ninput = sys.stdin.readline\n\nif __name__ == &#39;__main__&#39;:\n    result_count = 0 # 정답 Count\n    n, m = map(int, input().split()) # 수열의 개수, 나누어 떨어져야 하는 수\n    a = [i for i in map(int, input().split())] # 원본 배열\n    s = [0 for _ in range(n)] # 합 배열\n    c = [0] * m # 같은 나머지의 인덱스를 카운트하는 리스트\n\n    # 합 배열(s)의 0번 index 값을 원본 배열(a) 0번으로 초기화\n    s[0] = a[0]\n\n    # 합 배열(s)의 1번 index부터 구간 합을 계산하여 저장\n    for i in range(1, n):\n        s[i] = a[i] + s[i-1]\n\n    # 합 배열(s)에 m으로 나눈 나머지 값을 저장하고, 만약 해당 나머지가 0이면 result_count에 플러스 해준다.\n    # 같은 나머지의 인덱스를 카운트하는 리스트(c)에 해당 나머지 값과 동일한 index 내에 count를 증가해줌\n    for i in range(n):\n        s[i] = s[i] % m\n        if s[i] == 0 :\n            result_count += 1\n        c[s[i]] += 1\n\n    # 나누어 떨어져야 하는 수(m) 까지 반복하면서, 만약 c[i] 가 1보다 클 경우\n    # c[i] * (c[i]-1) 를 계산한 후 2로 나눈 값을 result_count에 더한다. (combination 공식)\n    for i in range(m):\n        if c[i] &amp;gt; 1:\n            result_count += (c[i] * (c[i]-1) // 2)\n\n    # 정답 출력\n    print(result_count)\n\n\n도식화\n\n\n\n결과\n\n\n"
} ,
  
  {
    "title"    : "[Python]백준 : 11660 구간 합 구하기 5",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/04/13/Python-Prefix-sum-5.html",
    "date"     : "April 13, 2023",
    "excerpt"  : "백준 : 11660 구간 합 구하기 5\n\n문제\n\nN×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.\n\n예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.\n\n\n  \n    \n      1\n      2\n      3\n      4\n    \n  \n  \n    \n      2\n      3\n      4\n   ...",
  "content"  : "백준 : 11660 구간 합 구하기 5\n\n문제\n\nN×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.\n\n예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.\n\n\n  \n    \n      1\n      2\n      3\n      4\n    \n  \n  \n    \n      2\n      3\n      4\n      5\n    \n    \n      3\n      4\n      5\n      6\n    \n    \n      4\n      5\n      6\n      7\n    \n  \n\n\n여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.\n\n표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.\n\n입력\n\n첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2 가 주어지며, (x1, y1)부터 (x2, y2)의 합을 구해 출력해야 한다. 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다. (x1 ≤ x2, y1 ≤ y2)\n\n출력\n\n총 M줄에 걸쳐 (x1, y1)부터 (x2, y2)까지 합을 구해 출력한다.\n\n예제 입력 1\n\n4 3\n1 2 3 4\n2 3 4 5\n3 4 5 6\n4 5 6 7\n2 2 3 4\n3 4 3 4\n1 1 4 4\n\n\n\n예제 출력 1\n\n27\n6\n64\n\n\n\n예제 입력 2\n\n2 4\n1 2\n3 4\n1 1 1 1\n1 2 1 2\n2 1 2 1\n2 2 2 2\n\n\n\n예제 출력 2\n\n1\n2\n3\n4\n\n\n\n출처\n\n11660번: 구간 합 구하기 5\n\n알고리즘 분류\n\n\n  다이나믹 프로그래밍\n  누적 합\n\n\n\n\n풀이\n\nimport sys\n\nif __name__ == &quot;__main__&quot;:\n    n, m = map(int, sys.stdin.readline().split())\n\n\t\t# 원본 배열 A 초기화\n    A = [[0] * (n + 1)] \n\t\t# 원본 테이블에서 구간합을 구하여 저장할 배열 D 초기화 \n    D = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n\n\t\t#원본 배열 A 데이터를 입력받아 append\n    for i in range(n):\n        A_row = [0] + [int(x) for x in sys.stdin.readline().split()]\n        A.append(A_row)\n\n\t\t# (1,1)부터 사용하므로 반복을 1부터 n+1까지 진행\n\t\t# 구간합을 계산하여 배열 D에 저장\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            D[i][j] = D[i-1][j] + D[i][j-1] - D[i-1][j-1] + A[i][j]\n\n\t\t# x1, y1, x2, y2 를 m 만큼 반복하여 입력받고,\n\t\t# 입력 받은 후 계산하여 출력\n    for _ in range(m):\n        x1, y1, x2, y2 = map(int, sys.stdin.readline().split())\n        this_result = D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]\n        print(this_result) # 결과 값 출력\n\n\n풀이 과정 (도식화)\n\n\n\n결과\n\n\n"
} ,
  
  {
    "title"    : "[데이터 포맷]  JSON &amp; XML",
    "category" : "",
    "tags"     : " JSON, XML",
    "url"      : "/syntax/2023/04/13/JSON-XML.html",
    "date"     : "April 13, 2023",
    "excerpt"  : "데이터 - 이론을 세우는 데 기초가 되는 사실, 또는 바탕이 되는 자료나 관찰이나 실험, 조사로 얻은 사실이나 자료 등을 의미\n\n데이터는 복잡성을 지닌다. 이러한 데이터를 컴퓨터가 주고 받으려면 어떤 약속(포맷)을 정하고 주고 받아야 한다. 어떻게 “표현”하는가에 대한 답.\n\n대표적으로 JSON, XML이 있다.\n\n#1. JSON\n\n\n  JSON(JavaScript Object Notation) 은 Javascript 객체 문법으로 구조화...",
  "content"  : "데이터 - 이론을 세우는 데 기초가 되는 사실, 또는 바탕이 되는 자료나 관찰이나 실험, 조사로 얻은 사실이나 자료 등을 의미\n\n데이터는 복잡성을 지닌다. 이러한 데이터를 컴퓨터가 주고 받으려면 어떤 약속(포맷)을 정하고 주고 받아야 한다. 어떻게 “표현”하는가에 대한 답.\n\n대표적으로 JSON, XML이 있다.\n\n#1. JSON\n\n\n  JSON(JavaScript Object Notation) 은 Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 표준 포맷이다.\n  위에서 설명하듯 JSON은 Javascript 객체 문법을 따르는 문자열이다. JSON 안에는 마찬가지로 Javascript의 undefined를 제외한 기본 데이터 타입인 문자열, 숫자, 배열, 불리언 그리고 다른 객체를 포함할 수 있다.\n  자바스크립트와 호환성이 좋다.\n\n\n{\n    &quot;question_type&quot;: &#39;GAIQ&#39;,\n    &quot;question_id&quot;: 1,\n    &quot;question_name&quot;: &#39;필터가 적용된 후 필터링 된 데이터를 복구할 수 있는 옵션은?&#39;,\n    &quot;question_content&quot;: [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],\n    &quot;question_description&quot;: &#39;보기에 필터를 적용한 뒤 처리한 데이터는 복구할 수 없습니다.\\n&#39; +\n        &#39;필터가 적용한 시점을 기준으로 전/후의 데이터가 달라지므로 일반적으로 보기 생성시점에 필터 설정 작업을 진행합니다.\\n&#39; +\n        &#39;(필터 설정 시, 효과가 데이터에 적용되기까지 최대 24시간 소요)&#39;,\n\t\t&quot;question_correct&quot;: 3,\n    &quot;question_reference&quot;: [\n        {\n            &quot;title&quot;: &quot;구글 도움말&quot;,\n            &quot;author&quot;: &quot;Google&quot;,\n            &quot;link&quot;: &quot;https://support.google.com/analytics/answer/6086075&quot;\n        }\n    ],\n    &quot;question_tag&quot;: [&quot;GAIQ&quot;, &quot;Google Analytics&quot;, &quot;필터링&quot;, &quot;필터&quot;],\n    &quot;question_create&quot;: new Date(),\n    &quot;question_edited&quot;: new Date(),\n    &quot;question_view&quot;: 213,\n},\n{\n    &quot;question_type&quot;: &#39;GAIQ&#39;,\n    &quot;question_id&quot;: 2,\n    &quot;question_name&quot;: &#39;자동 태그 추가를 통해 데이터를 수집하는 트래픽 종류는?&#39;,\n    &quot;question_content&quot;: [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],\n    &quot;question_description&quot;: &#39;Google Ads에서는 Google Ads 전환 추적 및 광고 클릭에 대한 성과 측정을 위한 목적으로 자동 태그를 설정할 수 있습니다.\\n&#39; +\n        &#39;사용자가 광고를 클릭하면 자동 태그 추가 기능에서 추가 정보(\\&#39;Google 클릭 식별자의\\&#39;의 약어인 GCLID라는 매개변수)를 사용자가 클릭하여 연결된 URL에 추가합니다.\\n&#39; +\n        &#39;자동 태그 추가 기능은 다음을 수행하기 전에 설정해야 하는 기능입니다.\\n&#39; +\n        &#39;- 모든 브라우저에서 웹사이트에서 발생한 전환 추적\\n&#39; +\n        &#39;- Google 애널리틱스를 비롯한 기타 외부 소스 (예: 고객 관계 관리(CRM) 시스템)의 전환 데이터를 Google Ads로 가져오기\\n&#39; +\n        &#39;- Google Ads 캠페인 및 비용 데이터를 Google 애널리틱스 보고서로 가져오기\\n&#39; +\n        &#39;- 이탈률, 평균 세션 시간 등의 Google 애널리틱스 사이트 참여 측정항목을 Google Ads 보고서로 가져오기\\n&#39;\n    ,\n\t\t&quot;question_correct&quot;: 2,\n    &quot;question_reference&quot;: [\n        {\n            &quot;title&quot;: &quot;구글 도움말&quot;,\n            &quot;author&quot;: &quot;Google&quot;,\n            &quot;link&quot;: &quot;https://support.google.com/analytics/answer/6086075&quot;\n        }\n    ],\n    &quot;question_tag&quot;: [&quot;GAIQ&quot;, &quot;Google Analytics&quot;, &quot;소셜 미디어&quot;, &quot;Google Ads 캠페인&quot;, &quot;검색 엔진 트래픽&quot;],\n    &quot;question_create&quot;: new Date(),\n    &quot;question_edited&quot;: new Date(),\n    &quot;question_view&quot;: 213,\n}\n\n\n\n  key : value 형태로 나타낸다.\n  자바스크립트가 느슨한 타입의 언어이기 때문에 각 객체는 서로 다른 타입을 가지고 있어도 문제 없다.\n\n\n// 각 객체가 서로 같은 타입을 가지고 있는 경우\n{\n\t&quot;지브리OST리스트&quot; : [\n\t\t{\n\t\t\t&quot;name&quot; : &quot;마녀 배달부 키키&quot;,\n\t\t\t&quot;song&quot; : &quot;따스함에 둘러 쌓인다면&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;name&quot; : &quot;하울의 움직이는 성&quot;,\n\t\t\t&quot;song&quot; : &quot;세계의 약속&quot;\n\t\t}\n\t]\n}\n\n// 각 객체가 서로 다른 타입을 가지고 있는 경우\n{\n\t&quot;지브리OST리스트&quot; : [\n\t\t{\n\t\t\t&quot;name&quot; : &quot;마녀 배달부 키키&quot;,\n\t\t\t&quot;song&quot; : &quot;따스함에 둘러 쌓인다면&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;name&quot; : &quot;하울의 움직이는 성&quot;,\n\t\t\t&quot;song&quot; : 1\n\t\t}\n\t]\n}\n\n\nJSON 참조 방법\n\nconst a = {\n\t&quot;지브리OST리스트&quot; : [\n\t\t{\n\t\t\t&quot;name&quot; : &quot;마녀 배달부 키키&quot;,\n\t\t\t&quot;song&quot; : &quot;따스함에 둘러 쌓인다면&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;name&quot; : &quot;하울의 움직이는 성&quot;,\n\t\t\t&quot;song&quot; : &quot;세계의 약속&quot;\n\t\t}\n\t]\n}\n\nconsole.log(a.지브리OST리스트[0])\nconsole.log(a.지브리OST리스트[0].name)\nconsole.log(a.지브리OST리스트[0][&quot;song&quot;])\n\n\n\n  앞의 코드처럼 배열은 [0], [1] 으로 배열의 index 값에 접근하면 되고, 해당 key에 대한 value는 .key 또는 [”key”]\n\n\nJSON 주의할점\n\n\n  JSON은 순수한 데이터 포맷이다.\n  오직 key - value 들만 담을 수 있다.\n  메서드는 담을 수 없다.\n  작은 따옴표가 아닌 큰 따옴표만을 사용해야 한다.\n  undefined는 불가하다.\n\n\n{\n\t&quot;지브리OST리스트&quot; : [\n\t\t{\n\t\t\t&#39;name&#39; : undefined, // X\n\t\t\t&quot;song&quot; : &quot;따스함에 둘러 쌓인다면&quot;\n\t\t},\n\t\t{\n\t\t\t&quot;name&quot; : &quot;하울의 움직이는 성&quot;,\n\t\t\t&quot;song&quot; : &quot;세계의 약속&quot;\n\t\t}\n\t]\n}\n\n\nJSON의 자료형\n\n\n  자바스크립트와 유사하지만 undefined, 메서드 등을 포함하지는 않는다.\n    \n      수 (Number)\n      문자열 (String)\n      참 / 거짓 (Boolean)\n      배열 (Array)\n      객체 (Object)\n      null\n    \n  \n\n\nJSON의 장점\n\n\n  JSON은 텍스트로 이루어져 있으므로, 사람과 컴퓨터 모두 읽고 쓰기가 쉽다.\n  프로그래밍 언어와 플랫폼에 독립적이므로, 서로 다른 시스템간에 객체를 교환하기에 좋다.\n  주로 API, config 파일에 활용되며 읽고 쓰며 가볍다.\n\n\n\n\n#2.XML\n\n데이터 비교\n\nJSON\n\n{\n\t&quot;CSKnowledgeList&quot; : [\n\t\t{\n\t\t\t&quot;name&quot; : &quot;디자인패턴&quot;,\n\t\t\t&quot;difficult&quot; : 5,\n\t\t},\n\t\t{\n\t\t\t&quot;name&quot; : &quot;네트워크&quot;,\n\t\t\t&quot;difficult&quot; : 4,\n\t\t}\n\t]\n}\n\n\nXML\n\n&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;\n&amp;lt;CSKnowledgeList&amp;gt;\n\t&amp;lt;CS&amp;gt;\n\t\t&amp;lt;name&amp;gt;디자인패턴&amp;lt;/name&amp;gt; &amp;lt;difficult&amp;gt;5&amp;lt;/difficult&amp;gt;\n\t&amp;lt;/CS&amp;gt;\n\t&amp;lt;CS&amp;gt;\n\t\t&amp;lt;name&amp;gt;네트워크&amp;lt;/name&amp;gt; &amp;lt;difficult&amp;gt;4&amp;lt;/difficult&amp;gt;\n\t&amp;lt;/CS&amp;gt;\n&amp;lt;/CSKnowledgeList&amp;gt;\n\n\n\n  위는 JSON이고, 아래가 XML(Extensible Markup Language)이다. 이런식으로 중괄호가 아니라 열린 태그 닫힌 태그로 이루어진 구조의 데이터를 의미한다.\n  xml 옆에 version을 쓰고 encoding을 쓴다. 보통은 utf-8이며 이 한 줄을 프롤로그라고 한다.\n  CSKnowledgeList라는 태그로 감싸져있는데 이러한 최상위태그는 하나만 사용이 가능하다.\n  JSON과 비교했을 때 닫힌 태그가 계속해서 들어가기 때문에 JSON과 비교하면 무겁다. 또한 Javascript Object로 변환하기 위해서 JSON보다는 더 많은 노력이 필요하다. (JSON은 JSON.parse 면 변환가능)\n\n\nhtml과 비교를 하기도 하는데 html의 태그는 정해져있다. body, p, div 등으로 말이다. 그러나 xml에는 기존 제공 이름이 없다.\n\n대표적인 사용사례 sitemap.xml\n\n\n  xml은 대표적으로 sitemap.xml에 쓰인다.\n  매우 큰 사이트의 경우 크기로 인해 Google 웹 크롤러가 신규 또는 최근에 업데이트된 페이지를 지나칠 수 있고, 서로 링크가 종속적으로 연결되지 않은 경우 Google이 일부 페이지를 누락하는 일이 있는데 이를 sitemap.xml이 방지한다.\n\n\n&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;\n&amp;lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;?&amp;gt;\n\t&amp;lt;url&amp;gt;\n\t\t&amp;lt;loc&amp;gt;http://www.example.com/foo.html&amp;lt;/loc&amp;gt;\n\t\t&amp;lt;lastmod&amp;gt;2018-06-04&amp;lt;/lastmod&amp;gt;\n\t&amp;lt;/url&amp;gt;\n\t&amp;lt;url&amp;gt;\n\t\t&amp;lt;loc&amp;gt;http://www.example.com/abc.html&amp;lt;/loc&amp;gt;\n\t\t&amp;lt;lastmod&amp;gt;2018-06-04&amp;lt;/lastmod&amp;gt;\n\t&amp;lt;/url&amp;gt;\n&amp;lt;/urlset&amp;gt;\n\n"
} ,
  
  {
    "title"    : "클라우드, SaaS, IaaS, PasS",
    "category" : "",
    "tags"     : " Cloud, SaaS, IaaS, PasS",
    "url"      : "/syntax/2023/04/13/Cloud-SaaS-IaaS-PaaS.html",
    "date"     : "April 13, 2023",
    "excerpt"  : "클라우드(Cloud)\n\n\n  인터넷을 통해 접근할 수 있는 서버 그리고 그 안에서 구동되는 소프트웨어, 데이터베이스 등을 의미함.\n\n\n\n\n\n  내 컴퓨터 장비를 사용하지 않고 컴퓨터 장비를 구축해 해야할 작업을 온라인에 분산되어 존재하는 데이터 센터(Data Center, 이하 클라우드)에 맡겨 수행하는 것을 말한다. 이렇게 되면 서버를 직접 구매할 때 고려해야 할 전력, 위치, 서버 세팅, 확장성을 고민하지 않고 서비스 운영에만 집중할 ...",
  "content"  : "클라우드(Cloud)\n\n\n  인터넷을 통해 접근할 수 있는 서버 그리고 그 안에서 구동되는 소프트웨어, 데이터베이스 등을 의미함.\n\n\n\n\n\n  내 컴퓨터 장비를 사용하지 않고 컴퓨터 장비를 구축해 해야할 작업을 온라인에 분산되어 존재하는 데이터 센터(Data Center, 이하 클라우드)에 맡겨 수행하는 것을 말한다. 이렇게 되면 서버를 직접 구매할 때 고려해야 할 전력, 위치, 서버 세팅, 확장성을 고민하지 않고 서비스 운영에만 집중할 수 있다. 이를 오프프레미스(off-premise) 방식이라고 한다.\n\n\n\n\nSaaS\n\n\n  SaaS(Software as a Service)는 인터넷을 통해 소프트웨어를 제공하는 방법이다. 완제품, 구글 드라이브, N드라이브, 구글 DOCS 등\n\n\nIaaS\n\n\n  IasS(Infrastructure-as-a-Service), 인프라를 제공 (서버와 저장소를 제공) 빈 방을 주는 것, 가상머신 위에서 애플리케이션의 각 컴포넌트가 구동된다. 특정 클라우드에 종속 x, 운영비가 상승한다. 이식성이 좋다. AWS의 EC2, NCP 등이 있다.\n  가상 머신 : 가상 컴퓨터, 컴퓨터 시스템을 에뮬레이션(가상현실화) 하는 소프트웨어\n\n\nPasS\n\n\n  PasS(Platform-as-a-Service) 는 플랫폼을 제공한다.\n  플랫폼을 제공, 빌트인 방. 운영비는 절감할 수 있고, 모니터링, CI/CD가 제공된다. 그러나 IaaS 보다는 유연하지 않고 플랫폼에 종속되게 되어있다. heroku 등이 있다.\n\n"
} ,
  
  {
    "title"    : "API (API, Application Programming Interface)",
    "category" : "",
    "tags"     : " API",
    "url"      : "/syntax/2023/04/13/API.html",
    "date"     : "April 13, 2023",
    "excerpt"  : "API (API, Application Programming Interface)\n\n\n  둘 이상의 컴퓨터 프로그램이 서로 통신하는 방법이자 컴퓨터 사이에 있는 중계 계층을 의미한다.\n  예를 들어 A라는 컴퓨터가 요청을 하고 B라는 컴퓨터가 응답을 한다고 했을 때의 어떻게 통신할 것인지, 어떠한 데이터를 주고 받을 건지 등에 대한 방법(HTTP, HTTPS 프로토콜을 사용할 것인지, GET, POST 등의 방식 등…) 이 정의된 중계계층인...",
  "content"  : "API (API, Application Programming Interface)\n\n\n  둘 이상의 컴퓨터 프로그램이 서로 통신하는 방법이자 컴퓨터 사이에 있는 중계 계층을 의미한다.\n  예를 들어 A라는 컴퓨터가 요청을 하고 B라는 컴퓨터가 응답을 한다고 했을 때의 어떻게 통신할 것인지, 어떠한 데이터를 주고 받을 건지 등에 대한 방법(HTTP, HTTPS 프로토콜을 사용할 것인지, GET, POST 등의 방식 등…) 이 정의된 중계계층인 것이다.\n  사용자 인터페이스(UI)를 생각하면 쉽다. UI는 컴퓨터와 사람을 연결한다. 다음 그림은 삼성 갤럭시의 UI이다. 이러한 핸드폰의 화면을 기반으로 사용자는 휴대폰과 상호작용을 할 수 있다.\n\n\n\n\n\n  사용자가 브라우저를 통해서 서버에 요청을 하게 되면 API가 중계계층역할을 하며 요청을 처리하는 것을 확인할 수 있다. 직접 서버의 데이터베이스에 접근 하는 것을 방지하기도 하는 것을 볼 수 있다.\n\n\nAPI의 장점\n\n\n  제공자는 서비스의 중요한 부분을 드러내지 않아도 된다. 예를 들어 DB 설계 구조나 드러내고 싶지 않은 데이터베이스의 테이블 정보, 서버의 상수값 등을 드러내지 않고 드러내고 싶은 부분만을 드러낼 수 있다.\n  사용자는 해당 서비스가 어떻게 구현되는지 알 필요없이 필요한 정보만을 받을 수 있다.\n  OPEN API의 경우 앱 개발 프로세스를 단순화 시키고 시간과 비용을 절약할 수 있다.\n  제공자의 경우 API를 만들게 되면 내부 프로세스가 수정 되었을 때 매번 수정하는 것이 아닌 API가 수정이 안되게끔 만들 수 있다. 또한 내부가 변경이 되어도 사용자에게 영향을 주지 않고 변경이 가능하다.\n  제공자는 데이터를 한 곳에 모을 수 있다. 예를 들어 예스24라는 책을 파는 쇼핑몰을 만들었다고 하면 해당 사이트에 방문하는 방문자,\n\n\nAPI의 종류\n\n\n  private : 내부적으로 사용된다. 주로 해시키를 하드코딩해놓고 이를 기반으로 서버와 서버간의 통신을 한다. 이는 비즈니스 파트너와도 사용될 수 있다. private하게도 해당 파트너와 해시키를 공유해 통신한다.\n  public : 모든 사람이 사용할 수 있다. 많은 트래픽을 방지하기 위해 하루 요청수의 제한, 계정당 몇 개 등으로 관리한다.\n\n"
} ,
  
  {
    "title"    : "1929 : (재귀함수) 우박수 (3n+1) (reverse)",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/02/26/codeup-codetest-collatz-reverse.html",
    "date"     : "February 26, 2023",
    "excerpt"  : "문제 링크 :\n\n(재귀함수) 우박수 (3n+1) (reverse)\n\n문제 설명\n\n콜라츠의 추측, 3n + 1 문제, 우박수 문제라고 불리는 이 문제는 다음과 같다.\n\n\n  어떤 자연수 n이 입력되면,\n  n이 홀수이면 3n + 1을 하고,\n  n이 짝수이면 n/2 를 한다.\n  이 n이 1이 될때까지 2 3 과정을 반복한다.\n\n\n예를 들어 5는 5 → 16 → 8 → 4 → 2 → 1 이 된다.\n\n그런데 이번에는 이 순서의 역순을 출력하고...",
  "content"  : "문제 링크 :\n\n(재귀함수) 우박수 (3n+1) (reverse)\n\n문제 설명\n\n콜라츠의 추측, 3n + 1 문제, 우박수 문제라고 불리는 이 문제는 다음과 같다.\n\n\n  어떤 자연수 n이 입력되면,\n  n이 홀수이면 3n + 1을 하고,\n  n이 짝수이면 n/2 를 한다.\n  이 n이 1이 될때까지 2 3 과정을 반복한다.\n\n\n예를 들어 5는 5 → 16 → 8 → 4 → 2 → 1 이 된다.\n\n그런데 이번에는 이 순서의 역순을 출력하고자 한다.\n\n즉, 1 2 4 8 16 5 가 출력되어야 한다.\n\n이 처럼 어떤 자연수 n이 입력되면 위 알고리즘에 의해 1이 되는 과정을 모두 출력하시오.\n\n금지 키워드 : for while goto\n\n입력\n\n자연수 n이 입력된다. (1 ≤ n ≤ 100,000,000)\n\n출력\n\n3n + 1의 과정을 출력한다.\n\n입력 예시\n\n5\n\n출력 예시\n\n1\n\n2\n\n4\n\n8\n\n16\n\n5\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solution(a):\n    answer = &#39;&#39;\n\n    def collatz(num):\n        if num == 1:\n            return print(1)\n\n        if num % 2 == 0:\n            collatz(num//2)\n        else:\n            collatz((3 * num) + 1)\n        return print(num)\n\n    collatz(a);\n\n    return answer\n\nA = int(input())\n\ntest_val = solution(A)\n\n"
} ,
  
  {
    "title"    : "코드 업 : 1928 : (재귀함수) 우박수 (3n + 1) (basic)",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/02/26/codeup-codetest-collatz-basic.html",
    "date"     : "February 26, 2023",
    "excerpt"  : "문제 링크 :\n\n(재귀함수) 우박수 (3n+1) (basic)\n\n문제 설명\n\n콜라츠의 추측, 3n + 1 문제, 우박수 문제라고 불리는 이 문제는 다음과 같다.\n\n\n  어떤 자연수 n이 입력되면,\n  n이 홀수이면 3n + 1을 하고,\n  n이 짝수이면 n/2 를 한다.\n  이 n이 1이 될때까지 2 3 과정을 반복한다.\n\n\n예를 들어 5는 5 → 16 → 8 → 4 → 2 → 1 이 된다.\n\n이 처럼 어떤 자연수 n이 입력되면 위 알고리...",
  "content"  : "문제 링크 :\n\n(재귀함수) 우박수 (3n+1) (basic)\n\n문제 설명\n\n콜라츠의 추측, 3n + 1 문제, 우박수 문제라고 불리는 이 문제는 다음과 같다.\n\n\n  어떤 자연수 n이 입력되면,\n  n이 홀수이면 3n + 1을 하고,\n  n이 짝수이면 n/2 를 한다.\n  이 n이 1이 될때까지 2 3 과정을 반복한다.\n\n\n예를 들어 5는 5 → 16 → 8 → 4 → 2 → 1 이 된다.\n\n이 처럼 어떤 자연수 n이 입력되면 위 알고리즘에 의해 1이 되는 과정을 모두 출력하시오.\n\n금지 키워드 : for while goto\n\n입력\n\n자연수 n이 입력된다. (1 ≤ n ≤ 100,000,000)\n\n단, 3n + 1이 되는 과정에서 int범위를 넘는 수는 입력으로 주어지지 않는다.\n\n출력\n\n3n + 1의 과정을 출력한다.\n\n입력 예시\n\n5\n\n출력 예시\n\n5\n\n16\n\n8\n\n4\n\n2\n\n1\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solution(a):\n    answer = &#39;&#39;\n    print(a)\n    \n    def collatz(num):\n        if num == 1:\n            return\n\n        if num % 2 == 0:\n            print(num//2)\n            return collatz(num//2)\n        else :\n            print((3 * num) + 1)\n            return collatz((3 * num) + 1)\n\n    collatz(a);\n\n    return answer\n\nA = int(input())\n\nsolution(A)\n\n"
} ,
  
  {
    "title"    : "코드 업 : 1920 : (재귀함수) 2진수 변환",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/02/26/codeup-codetest-binaryparse.html",
    "date"     : "February 26, 2023",
    "excerpt"  : "문제 링크 :\n\n(재귀함수) 2진수 변환\n\n문제 설명\n\n어떤 10진수 �이 주어지면 2진수로 변환해서 출력하시오.\n\n예)\n\n10    —–&amp;gt;  1010\n\n0    —–&amp;gt;  0\n\n1    —–&amp;gt;  1\n\n2    —–&amp;gt;  10\n\n1024    —–&amp;gt;  10000000000\n\n이 문제는 반복문을 이용하여 풀 수 없습니다.\n\n금지 키워드 : for while goto\n\n입력\n\n10진수 정수 n이 입력된다.\n\n(0 ≤ n...",
  "content"  : "문제 링크 :\n\n(재귀함수) 2진수 변환\n\n문제 설명\n\n어떤 10진수 �이 주어지면 2진수로 변환해서 출력하시오.\n\n예)\n\n10    —–&amp;gt;  1010\n\n0    —–&amp;gt;  0\n\n1    —–&amp;gt;  1\n\n2    —–&amp;gt;  10\n\n1024    —–&amp;gt;  10000000000\n\n이 문제는 반복문을 이용하여 풀 수 없습니다.\n\n금지 키워드 : for while goto\n\n입력\n\n10진수 정수 n이 입력된다.\n\n(0 ≤ n ≤ 2, 100,000,000)\n\n출력\n\n2진수로 변환해서 출력한다.\n\n입력 예시\n\n7\n\n출력 예시\n\n111\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solution(a):\n    answer = &#39;&#39;\n\n    def parseBinary(num, answer):\n        if num == 1 or num == 0:\n            answer += str(num)\n            return answer[::-1] # answer 문자열을 뒤집은 새로운 문자열을 반환하는 것\n\n        answer += str(num % 2)\n        return parseBinary(num // 2, answer)\n\n    answer = parseBinary(a, answer)\n\n    return answer\n    \ninput_val = int(input())\ntest_val = solution(input_val)\n\nprint(test_val)\n\n"
} ,
  
  {
    "title"    : "[Front-end CS] 브라우저 렌더링 프로세스",
    "category" : "",
    "tags"     : " Front-end, Computer Science, Browser",
    "url"      : "/syntax/2023/02/26/Front-end-cs-browser-rendering.html",
    "date"     : "February 26, 2023",
    "excerpt"  : "Browser Rendering Process\n\n\n  Browser Elements\n  Browser Rendering Process\n    \n      rendering engine(webkit) working process\n      HTML, CSS parsing process\n      render process\n    \n  \n\n\n브라우저 기본 구조 (Browser Elements)\n\n\n\n\n  사용자 인터페이스 - 주소 표시줄, 이...",
  "content"  : "Browser Rendering Process\n\n\n  Browser Elements\n  Browser Rendering Process\n    \n      rendering engine(webkit) working process\n      HTML, CSS parsing process\n      render process\n    \n  \n\n\n브라우저 기본 구조 (Browser Elements)\n\n\n\n\n  사용자 인터페이스 - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분\n  브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어\n  렌더링 엔진 - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시 (요청한 URI를 브라우저 엔진에게 받아서 server에게 요청한다.(통신) server로 부터 URI에 해당하는 데이터(HTML,CSS,JavaScript)를 받아서 파싱한 후 렌더링한다. (chrome webkit)\n  통신 - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고, 각 플랫폼 하부에서 실행된다. (렌더링 엔진으로부터 HTTP 요청 등을 받아서 네트워크 처리 후 응답을 전달한다.)\n  UI 백엔드 - render tree를 browser에 그리는 역할을 담담 (콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.)\n  자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행한다. (chrome V8 엔진)\n  자료 저장소 - 쿠키 등의 자료를 컴퓨터 하드디스크에 저장한다. (HTML5 부터 Web Database에 저장가능)\n\n\n브라우저가 렌더링하는 과정 (Browser Rendering Process)\n\n\n  사용자가 사용자 인터페이스 내부 주소표시줄에 URI를 입력하여 브라우저 엔진에 전달\n  브라우저 엔진은 자료 저장소에서 URI에 해당하는 자료를 찾고, 해당 자료를 쿠키로 저장했다면 그 자료를 렌더링 엔진에 전달\n  렌더링 엔진은 브라우저 엔진에서 가져온 자료(HTML, CSS, Image 등)를 분석하고, 동시에 URI 데이터를 통신, 자바스크립트 해석기, UI 백엔드로 전파한다.\n  또한 렌더링 엔진은 통신 레이어에 URI에 대한 추가 데이터(있을 경우)를 요청하고 응답할 때까지 기다린다.\n  응답받은 데이터에서 HTML, CSS는 렌더링 엔진이 파싱한다.\n  응답받은 데이터에서 JavaScript는 JavaScript 해석기가 파싱한다.\n  JavaScript 해석기는 파싱한 결과를 렌더링 엔진에 전달하여 3번과 5번에서 파싱한 HTML의 결과인 DOM tree를 조작한다.\n  조작이 완료된 DOM node(DOM tree의 구성요소)는 render object(render tree 구성요소)로 변한다.\n  UI 백엔드는 render object를 브라우저 렌더링 화면에 띄워준다.\n\n\nwebkit (rendering engine working process)\n\n\n  렌더링 엔진은 URI를 통해 요청을 받아서 해당하는 데이터를 렌더링하는 역할을 담당한다.\n  chrome 과 IOS는 ‘webkit’ 이라는 rendering engine을 사용한다.\n\n\n대략적인 rendering engine 동작 과정\n\n\n\n\n  DOM tree 구축을 위한 HTML parsing, CSS, Javascript parsing : HTML 문서를 파싱한 후, content tree 내부에서 tag(a, div)를 DOM node 로 변환한다. 그 다음 CSS 파일과 함께 모든 스타일 요소를 파싱한다. 스타일 요소와 HTML 표시 규칙, Javascript 의 파싱 결과물은 render tree를 생성한다.\n  render tree 구축 : HTML 과 CSS 를 파싱해서 만들어진 render tree 는 색상 또는 면적 등 시각적 속성을 갖는 사각형을 포함한다. 정해진 순서대로 렌더링한다.\n  render tree 배치 : render tree가 생성이 끝나면, 배치가 시작된다. 각 node가 정확한 위치에 표시되기 위해 이동한다.\n  render tree 그리기 : 각 node 배치를 완료하면 UI 백엔드에서 각 node를 가로지르며 paint 작업을 한다.\n\n\n해당 작업 1번과 2, 3, 4번은 병력적으로 진행된다.\n\n통신 레이어에서 data를 계속 받아오면서(통신 레이어)\n\n받아온 HTML, CSS, Javascript 를 parsing 하면서 (1번)\n\nrender tree에 node를 그린다 (2, 3, 4번)\n\nwebkit의 동작 과정\n\n\n\n\n  HTML을 parsing 하여 DOM tree 를 생성한다.\n    \n      아래와 같은 HTML을 parsing하여 DOM tree를 생성한다. (DOM 으로 바꾼 HTML은 Javascript가 조작할 수 있다.)\n  -\n    \n\n     &amp;lt;html&amp;gt;\n \t&amp;lt;body&amp;gt;\n \t\t&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;\n \t\t&amp;lt;div&amp;gt;\n \t\t\t&amp;lt;img src=&quot;example.png&quot; /&amp;gt;\n \t\t&amp;lt;/div&amp;gt;\n \t\t&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;\n \t&amp;lt;/body&amp;gt;\n &amp;lt;/html&amp;gt;\n    \n  \n\n\n\n\n브라우저는 tag의 parsing과 실행을 동시에 진행한다.\n\n그러므로 아래 과정으로 HTML tag를 parsing 한다.\n\n\n  \n\n\n\n  \n    \n  \n  \n    \n  \n  실행이 완료된 후 다음 tag를 파싱한다.\n\n\n\n  \n\n\n그러므로\n\nHTML5에서 추가된 기능이 있다.\n\n\n  HTML5에서는 \n\n  \n    CSS(style sheets)를 parsing 하여 스타일 규칙을 얻는다.\n      \n        ‘webkit’ 은 CSS 문법 파일로부터 자동으로 파서를 생성하기 위해 플렉스와 바이슨 파서 생성기를 사용한다. 파서 소개에서 언급했던 것처럼 바이슨은 상향식 이동 감소 파서를 생성한다. 파이어폭스는 직접 작성한 하향식 파서를 사용한다. 두 경우 모두 각 CSS 파일은 스타일 시트 객체로 파싱되고 각 객체는 CSS 규칙을 포함한다. CSS 규칙 객체는 선택자와 선언 객체 그리고 CSS 문법과 일치하는 다른 객체를 포함한다.\n        css parsing 하여 CSSOM 생성\n      \n    \n    DOM tree를 생성하는 동시에, 이미 생성된 DOM tree와 스타일 규칙(CSSOM)을 Attachment 한다.\n      \n        DOM tree를 구성하는 하나의 DOM node는 attach 라는 method를 가진다. (새로운 DOM node가 추가되면 attach가 호출되어 render object를 생성한다.)\n        render object는 render tree의 구성요소로써, 자신과 자식 요소를 어떻게 배치하고 그려야할지 안다.\n        node의 css box를 표시할 정보를 가지고 있다.\n        모든 DOM node가 전부 render obejct로 생성되는 것은 아니다.(ex head tag, display none tag 등)\n        \n          과  DOM node 또한 render object로 구성되는데 이들은 render tree root 로써 render view 라고 부른다.\n\n        \n        나머지 DOM node 들은 render object로 생성되어 이 render tree root에 추가된다.\n      \n    \n    구축한 render tree를 배치(layout)한다.\n      \n        배치는 &amp;lt;html&amp;gt; 요소에 해당하는 최상위 render object에서 시작한다. 화면에 왼쪽 위부터 render object에 해당하는 DOM node를 그려나간다.\n      \n    \n    배치가 끝난 render tree를 그린다.\n      \n        render tree 탐색 후 해당하는 render object의 paint method 를 호출한다.\n      \n    \n  \n\n\n모질라의 게코 렌더링 엔진 동작 과정\n\n\n\n\n\n참고 내용 및 출처 표시\n\n브라우저는 어떻게 동작하는가?\n\nBrowser rendering process 1편 - Browser 구성 요소\n\nBrowser rendering process 2편 - 렌더링 엔진 동작과정\n"
} ,
  
  {
    "title"    : "[Python] - 구현: 시뮬레이션과 완전 탐색",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/02/02/Python-implementation-bruteforce.html",
    "date"     : "February 2, 2023",
    "excerpt"  : "구현(Implementation)\n\n\n  구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.\n\n\n\n\n\n  알고리즘 대회나 코딩 테스트에서의 구현 유형의 문제란?\n    \n      풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭한다.\n    \n  \n  구현 유형의 예시\n    \n      알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제\n      실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 ...",
  "content"  : "구현(Implementation)\n\n\n  구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.\n\n\n\n\n\n  알고리즘 대회나 코딩 테스트에서의 구현 유형의 문제란?\n    \n      풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭한다.\n    \n  \n  구현 유형의 예시\n    \n      알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제\n      실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제\n      문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제\n      적절한 라이브러리를 찾아서 사용해야 하는 문제\n    \n  \n  일반적으로 알고리즘 문제에서의 2차원 공간은 행렬(Matrix)의 의미로 사용된다.\n    \n      행렬(Matrix) : 2차원 데이터를 일종의 표와 같은 형태로 쉽게 나타낼 수 있는 것 (2차원 배열)\n    \n  \n\n\n\n  \n    \n       \n      열 (Column)\n       \n       \n       \n       \n    \n  \n  \n    \n      행 (Row)\n      (0, 0)\n      (0, 1)\n      (0, 2)\n      (0, 3)\n      (0, 4)\n    \n    \n       \n      (1, 0)\n      (1, 1)\n      (1, 2)\n      (1, 3)\n      (1, 4)\n    \n    \n       \n      (2, 0)\n      (2, 1)\n      (2, 2)\n      (2, 3)\n      (2, 4)\n    \n    \n       \n      (3, 0)\n      (3, 1)\n      (3, 2)\n      (3, 3)\n      (3, 4)\n    \n    \n       \n      (4, 0)\n      (4, 1)\n      (4, 2)\n      (4, 3)\n      (4, 4)\n    \n  \n\n\nfor i in range(5):\n\tfor j in range(5):\n\t\tprint(&#39;(&#39;, i, &#39;,&#39;, j &#39;)&#39;, end=&#39; &#39;)\n\tprint()\n\n\n\n  시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 방향 벡터가 자주 활용된다.\n\n\n\n  \n    \n       \n      열 (Column)\n       \n       \n       \n       \n    \n  \n  \n    \n      행 (Row)\n      (0, 0)\n      (0, 1)\n      (0, 2)\n      (0, 3)\n      (0, 4)\n    \n    \n       \n      (1, 0)\n      (1, 1)\n      (1, 2)\n      (1, 3)\n      (1, 4)\n    \n    \n       \n      (2, 0)\n      (2, 1)\n      (2, 2)\n      (2, 3)\n      (2, 4)\n    \n    \n       \n      (3, 0)\n      (3, 1)\n      (3, 2)\n      (3, 3)\n      (3, 4)\n    \n    \n       \n      (4, 0)\n      (4, 1)\n      (4, 2)\n      (4, 3)\n      (4, 4)\n    \n  \n\n\n# 동, 북, 서, 남\ndx = [0, -1, 0, 1]\ndy = [1, 0, -1, 0]\n\n# 현재 위치\nx, y = 2, 2\n\nfor i in range(4):\n\t# 다음 위치\n\tnx = x + dx[i]\n\tny = y + dy[i]\n\tprint(nx, ny)\n\n\n\n\n문제 1: 상하좌우\n\n\n  여행가 A는 N x N 크기의 정사각형 공간 위에 있습니다. 이 공간은 1 x 1 크기의 정사각형으로 나누어져 있습니다. 가장 왼쪽 위 좌표는 (1, 1) 이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당합니다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)입니다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있습니다.\n  계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있습니다. 각 문자의 의미는 다음과 같습니다.\n    \n      L: 왼쪽으로 한 칸 이동\n      R: 오른쪽으로 한 칸 이동\n      U: 위로 한 칸 이동\n      D: 아래로 한 칸 이동\n    \n  \n  이때 여행가 A가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시됩니다. 예를 들어 (1, 1)의 위치에서 L혹은 U를 만나면 무시됩니다. 다음은 N = 인 지도와 계획서입니다.\n\n\n\n\n입력조건\n\n\n  첫째 줄에 공간의 크기를 나타내는 N이 주어집니다. (1 ≤ N ≤ 100)\n  둘째 줄에 여행가 A가 이동할 계획서 내용이 주어집니다. (1 ≤ 이동 횟수 ≤ 100)\n\n\n출력조건\n\n\n  첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백을 기준으로 구분하여 출력합니다.\n\n\n입력예시\n\n\n  5\n\n  R R R U D D\n\n\n\n출력 예시\n\n\n  3 4\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndef solution(n, move):\n    answer = &#39;&#39;\n    move_arr = move.split()\n\n    # 현재 위치\n    x, y = 1, 1\n\n    for i in move_arr:\n        if i == &#39;L&#39;:\n            if x &amp;gt; 1:\n                x = x + -1\n        elif i == &quot;R&quot;:\n            if x &amp;lt; n:\n                x = x + 1\n        elif i == &quot;U&quot;:\n            if y &amp;gt; 1:\n                y = y + -1\n        elif i == &#39;D&#39;:\n            if y &amp;lt; n:\n                y = y + 1\n    answer = str(y) + &#39; &#39; + str(x)\n    return answer\n\ntc_data = [{&#39;tc_input1&#39;: 5, &#39;tc_input2&#39;:&#39;R R R U D D&#39;, &#39;tc_answer&#39;: &#39;3 4&#39;}, {&#39;tc_input1&#39;: 5, &#39;tc_input2&#39;:&#39;R U D L R R&#39;, &#39;tc_answer&#39;: &#39;2 3&#39;}, {&#39;tc_input1&#39;: 5, &#39;tc_input2&#39;:&#39;L R D D D R R&#39;, &#39;tc_answer&#39;: &#39;4 4&#39;}]\n\nfor for_index in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, for_index,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a, b = tc_data[for_index][&#39;tc_input1&#39;], tc_data[for_index][&#39;tc_input2&#39;]\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;b의 값은&#39;, b)\n    print(&#39;정답은&#39;, tc_data[for_index][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[for_index][&#39;tc_answer&#39;], solution(a, b))\n    end = time.time()\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n문제 2: 시각 문제\n\n\n  정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하세요. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각입니다.\n    \n      00시 00분 03초\n      00시 13분 30초\n    \n  \n  반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각입니다.\n    \n      00시 02분 55초\n      01시 27분 45초\n    \n  \n\n\n입력조건\n\n\n  첫째 줄에 정수 N이 입력됩니다. (0 ≤ N ≤ 23)\n\n\n출력조건\n\n\n  00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력합니다.\n\n\n입력예시\n\n\n  5\n\n\n\n출력 예시\n\n\n  11475\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndef solution(n):\n    answer = 0\n\n    for hour in range(n + 1):\n        for minute in range(60):\n            for second in range(60):\n                if &#39;3&#39; in str(hour) + str(minute) + str(second):\n                    answer += 1\n\n    return answer\n\ntc_data = [{&#39;tc_input1&#39;: 5, &#39;tc_answer&#39;: 11475}]\n\nfor for_index in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, for_index,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a= tc_data[for_index][&#39;tc_input1&#39;]\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;정답은&#39;, tc_data[for_index][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[for_index][&#39;tc_answer&#39;], solution(a))\n    end = time.time()\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n문제 3: 왕실의 나이트\n\n\n  행복 왕국의 왕실 정원은 체스판과 같은 8 x 8 좌표 평면입니다. 왕실 정원의 특정한 한 칸에 나이트가 서 있습니다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마합니다.\n  나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없습니다.\n  나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있습니다.\n    \n      수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기\n      수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기\n    \n  \n  이처럼 8 x 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하세요. 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할때는 a부터 h로 표현합니다.\n    \n      c2에 있을 때 이동할 수 있는 경우의 수는 6가지 입니다.\n      a1에 있을 때 이동할 수 있는 경우의 수는 2가지 입니다.\n    \n  \n\n\n\n\n입력조건\n\n\n  첫째 줄에 8 x 8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1처럼 열과 행으로 이뤄진다.\n\n\n출력조건\n\n\n  첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오.\n\n\n입력예시\n\n\n  a1\n\n\n\n출력 예시\n\n\n  2\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndx = [-2, 2, -2, 2, -1, -1, 1, 1]\ndy = [-1, -1, 1, 1, -2, 2, -2, 2]\n\ndef solution(n):\n    answer = 0\n    def parse_column(row_val):\n        if row_val == &#39;a&#39;:\n            return 1\n        elif row_val == &#39;b&#39;:\n            return 2\n        elif row_val == &#39;c&#39;:\n            return 3\n        elif row_val == &#39;d&#39;:\n            return 4\n        elif row_val == &#39;e&#39;:\n            return 5\n        elif row_val == &#39;f&#39;:\n            return 6\n        elif row_val == &#39;g&#39;:\n            return 7\n        elif row_val == &#39;h&#39;:\n            return 8\n    \n    x = int(parse_column(n[0]))\n    y = int(n[1])\n\n    for i in range(8):\n        nx = dx[i] + x\n        ny = dy[i] + y\n\n        if nx &amp;gt; 0 and ny &amp;gt; 0:\n            answer += 1\n\n    return answer\n\ntc_data = [{&#39;tc_input1&#39;: &#39;a1&#39;, &#39;tc_answer&#39;: 2}, {&#39;tc_input1&#39;: &#39;c2&#39;, &#39;tc_answer&#39;: 6}]\n\nfor for_index in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, for_index,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a= tc_data[for_index][&#39;tc_input1&#39;]\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;정답은&#39;, tc_data[for_index][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[for_index][&#39;tc_answer&#39;], solution(a))\n    end = time.time()\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n문제 4: 문자열 재정렬\n\n\n  알파벳 대문자와 숫자(0 ~ 9)로만 구성된 문자열이 입력으로 주어집니다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력합니다.\n  예를 들어 K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력합니다.\n\n\n입력조건\n\n\n  첫째 줄에 하나의 문자열 S가 주어집니다. (1 ≤ S의 길이 ≤ 10,000)\n\n\n출력조건\n\n\n  첫째 줄에 문제에서 요구하는 정답을 출력합니다.\n\n\n입력예시 1\n\n\n  K1KA5CB7\n\n\n\n출력 예시 1\n\n\n  ABCKK13\n\n\n\n입력예시 2\n\n\n  AJKDLSI412K4JSJ9D\n\n\n\n출력 예시 2\n\n\n  ADDIJJJKKLSS20\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndef solution(s):\n    answer = &#39;&#39;\n\n    arr_str = [s[i] for i in range(len(s))]\n\n    arr_str.sort()\n\n    sum_number = 0\n\n    for j in range(len(arr_str)):\n        if not arr_str[j].isalpha():\n            sum_number += int(arr_str[j])\n        else:\n            answer += arr_str[j]\n\n    answer += str(sum_number)\n\n    return answer\n\ntc_data = [{&#39;tc_input1&#39;: &#39;K1KA5CB7&#39;, &#39;tc_answer&#39;: &#39;ABCKK13&#39;}, {&#39;tc_input1&#39;: &#39;AJKDLSI412K4JSJ9D&#39;, &#39;tc_answer&#39;: &#39;ADDIJJJKKLSS20&#39;}]\n\nfor for_index in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, for_index,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a= tc_data[for_index][&#39;tc_input1&#39;]\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;정답은&#39;, tc_data[for_index][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[for_index][&#39;tc_answer&#39;], solution(a))\n    end = time.time()\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n참고자료\n\n(이코테 2021 강의 몰아보기) 2. 그리디 &amp;amp; 구현\n"
} ,
  
  {
    "title"    : "[Python] - 그리디 알고리즘",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/02/01/Python-greedy-algorithm.html",
    "date"     : "February 1, 2023",
    "excerpt"  : "그리디 알고리즘\n\n\n  그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.\n  일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.\n  그리디 해법은 그 정당성 분석이 중요하다.\n    \n      단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다.\n    \n  \n  일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 ...",
  "content"  : "그리디 알고리즘\n\n\n  그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.\n  일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.\n  그리디 해법은 그 정당성 분석이 중요하다.\n    \n      단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다.\n    \n  \n  일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다.\n  하지만 코딩 테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제된다고 한다.\n\n\n\n\n문제 1: 1이 될 때까지\n\n\n  어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.\n단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.\n    \n      N에서 1을 뺍니다.\n      N을 K로 나눕니다.\n    \n  \n  예를 들어 N이 17, K가 4라고 가정합시다. 이때 1번의 과정을 한 번 수행하면 N은 16이 됩니다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 됩니다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 됩니다. 이는 N을 1로 만드는 최소 횟수입니다.\n  N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하세요.\n\n\n입력조건\n\n\n  첫째 줄에 N(1 ≤ N ≤ 100,000)과 K(2 ≤ K ≤ 100,000)가 공백을 기준으로 하여 각각 자연수로 주어집니다.\n\n\n출력조건\n\n\n  첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력합니다.\n\n\n입력예시\n\n\n  25 5\n\n\n\n출력 예시\n\n\n  2\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndef solution(n, k):\n    answer = 0\n    while True:\n        if n % k == 0:\n            n = int(n / k)\n        else:\n            n = n - 1\n\n        answer += 1\n\n        if n == 1:\n            break\n    return answer\n\ntc_data = [{&#39;tc_input&#39;: &#39;17 4&#39;, &#39;tc_answer&#39;: 3}, {&#39;tc_input&#39;: &#39;25 5&#39;, &#39;tc_answer&#39;: 2}, {&#39;tc_input&#39;: &#39;25 3&#39;, &#39;tc_answer&#39;: 6}]\n\nfor i in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, i,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a, b = map(int, tc_data[i][&#39;tc_input&#39;].split())\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;b의 값은&#39;, b)\n    print(&#39;정답은&#39;, tc_data[i][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[i][&#39;tc_answer&#39;], solution(a, b))\n    end = time.time()\n\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n문제 2: 곱하기 혹은 더하기\n\n\n  각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 문자를 확인하며 숫자 사이에 ‘x’ 혹은 ‘+’ 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.\n  예를 들어 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2) x 9) x 8) x 4) = 576입니다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.\n\n\n입력조건\n\n\n  첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다. (1 ≤ S의 길이 ≤ 20)\n\n\n출력조건\n\n\n  첫째 줄에 만들어질 수 있는 가장 큰 수를 출력합니다.\n\n\n입력예시 1\n\n\n  02984\n\n\n\n출력 예시 1\n\n\n  576\n\n\n\n입력예시 2\n\n\n  567\n\n\n\n출력 예시 2\n\n\n  210\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndef solution(s):\n    answer = 0\n\n    for i in range(len(s)):\n        this_number = int(s[i])\n        if answer * this_number == 0:\n            answer += this_number\n            continue\n        else:\n            answer *= this_number\n\n    return answer\n\ntc_data = [{&#39;tc_input&#39;: &#39;02984&#39;, &#39;tc_answer&#39;: 576}, {&#39;tc_input&#39;: &#39;567&#39;, &#39;tc_answer&#39;: 210}, {&#39;tc_input&#39;: &#39;99999&#39;, &#39;tc_answer&#39;: 59049}]\n\nfor for_index in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, for_index,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a = tc_data[for_index][&#39;tc_input&#39;]\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;정답은&#39;, tc_data[for_index][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[for_index][&#39;tc_answer&#39;], solution(a))\n    end = time.time()\n\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n문제 3: 모험가 길드\n\n\n  한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 ‘공포도’를 측정했는데, ‘공포도’가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.\n  모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.\n  최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.\n  예를 들어 N = 5 이고, 각 모험가의 공포도가 다음과 같다고 가정합시다.\n\n\n\n  2 3 1 2 2\n\n  \n    이 경우 그룹 1에 공포도가 1, 2, 3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두 명을 넣게되면 총 2개의 그룹을 만들 수 있습니다.\n    또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없습니다.\n  \n\n\n입력조건\n\n\n  첫째 줄에 모험가의 수 N이 주어집니다. (1 ≤ N ≤ 100,000)\n  둘쨰 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분합니다.\n\n\n출력조건\n\n\n  여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.\n\n\n입력예시 1\n\n\n  5\n\n  2 3 1 2 2\n\n\n출력 예시 1\n\n\n  2\n\n\n\nimport time\n\ndef test(answer, test_data):\n    print(&#39;제출한 답:&#39;, test_data)\n    if test_data == answer:\n        print(&quot;정답입니다&quot;)\n    else:\n        print(&quot;오답입니다&quot;)\n\ndef solution(n, gongpodo):\n    answer = 0\n    count_people = 0\n    sort_numbers = sorted(gongpodo.split())\n\n    for i in range(n):\n        count_people += 1\n        if int(sort_numbers[i]) &amp;lt;= count_people:\n            count_people = 0\n            answer += 1\n    return answer\n\ntc_data = [{&#39;tc_input1&#39;: &#39;5&#39;, &#39;tc_input2&#39;:&#39;2 3 1 2 2&#39;, &#39;tc_answer&#39;: 2}, {&#39;tc_input1&#39;: &#39;10&#39;, &#39;tc_input2&#39;:&#39;2 3 1 2 2 2 2 1 1 2&#39;, &#39;tc_answer&#39;: 6}]\n\nfor for_index in range(len(tc_data)):\n    print(&#39;ㅡㅡㅡㅡ&#39;, for_index,&#39;번째 test&#39;, &#39;ㅡㅡㅡㅡ&#39;)\n    a, b = tc_data[for_index][&#39;tc_input1&#39;], tc_data[for_index][&#39;tc_input2&#39;]\n    print(&#39;a의 값은&#39;, a)\n    print(&#39;b의 값은&#39;, b)\n    print(&#39;정답은&#39;, tc_data[for_index][&#39;tc_answer&#39;])\n    start = time.time()\n    test(tc_data[for_index][&#39;tc_answer&#39;], solution(int(a), b))\n    end = time.time()\n    print(&#39;소요시간:&#39;,f&quot;{end - start:.5f} sec&quot;)\n\n\n\n\n\n\n참고자료\n\n(이코테 2021 강의 몰아보기) 2. 그리디 &amp;amp; 구현\n"
} ,
  
  {
    "title"    : "[Python] - 동적 프로그래밍 : 피보나치 수",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/01/30/Python-pibonacci.html",
    "date"     : "January 30, 2023",
    "excerpt"  : "피보나치 수열 문제\n\n프로그래머스 문제 (링크) - https://school.programmers.co.kr/learn/courses/30/lessons/12945\n\n\n\n피보나치 수\n\n언어 - Python3\n\n문제 설명\n\n피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.\n\n예를들어\n\n\n  F(2) = F(0) + F(1) = 0 + 1 = 1\n...",
  "content"  : "피보나치 수열 문제\n\n프로그래머스 문제 (링크) - https://school.programmers.co.kr/learn/courses/30/lessons/12945\n\n\n\n피보나치 수\n\n언어 - Python3\n\n문제 설명\n\n피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.\n\n예를들어\n\n\n  F(2) = F(0) + F(1) = 0 + 1 = 1\n  F(3) = F(1) + F(2) = 1 + 1 = 2\n  F(4) = F(2) + F(3) = 1 + 2 = 3\n  F(5) = F(3) + F(4) = 2 + 3 = 5\n\n\n와 같이 이어집니다.\n\n2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.\n\n제한 사항\n\n\n  n은 2 이상 100,000 이하인 자연수입니다.\n\n\n입출력 예\n\n\n  \n    \n      n\n      return\n    \n  \n  \n    \n      3\n      2\n    \n    \n      5\n      5\n    \n  \n\n\n입출력 예 설명\n\n피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, … 와 같이 이어집니다.\n\n\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\nanswer = [0, 1, 1]\ndef solution(n):\n    if n &amp;lt;= 0:\n        return 0\n    if n &amp;lt; len(answer):\n        return answer[n]\n    answer.append(solution(n-1) + solution(n-2))\n    return int(answer[n] % 1234567)\n\n\n\n  유튜브에서 피보나치 수열 관련 알고리즘을 좀 찾아봤는데, 보통 재귀적으로 구현하게 되면 1초 정도의 시간제한이 있을 경우 타임 아웃이 일어나는 것을 확인했다. 그래서 보통 이런 유형의 문제는 동적 프로그래밍(Dynamic Programming)을 통해 풀어야 시간 초과가 나지 않음을 확인하였고, 동적 프로그래밍의 경우 경험 정보를 이용하여 문제를 해결하기 때문에 빠른 연산이 가능하다.\n\n\n\n\n\n\n\n코드 업 : **1916 : (재귀함수) 피보나치 수열 (Large)**\n\nhttps://codeup.kr/problem.php?id=1916\n\n피보나치 수열이란 앞의 두 수를 더하여 나오는 수열이다.\n\n첫 번째 수와 두 번째 수는 모두 11이고, 세 번째 수부터는 이전의 두 수를 더하여 나타낸다. 피보나치 수열을 나열해 보면 다음과 같다.\n\n\n  1,1,2,3,5,8,13…\n\n\n\n자연수 N을 입력받아 N번째 피보나치 수를 출력하는 프로그램을 작성하시오.\n\n단, N이 커질 수 있으므로 출력값에 10,009를 나눈 나머지를 출력한다.\n\n※ 이 문제는 반드시 재귀함수를 이용하여 작성 해야한다.\n\n입력\n\n자연수 N이 입력된다. (N�은 200200보다 같거나 작다.)\n\n출력\n\nN번째 피보나치 수를 출력하되, 10,00910,009를 나눈 나머지 값을 출력한다.\n\n입력 예시  \n\n7\n\n출력 예시\n\n13\n\nimport sys\nsys.setrecursionlimit(10**7)\n\ndict = {} # 메모이제이션을 위한 딕셔너리\n\ndef pibonacchi(num):\n    if num in dict:\n        return dict[num]\n        \n    if num == 1 or num == 2:\n        dict[num] = 1\n        return dict[num]\n    else:\n        dict[num] = pibonacchi(num-1) + pibonacchi(num-2)\n        return dict[num] % 10009\n\ndef solution(a):\n    answer = pibonacchi(a)\n    print(answer)\n    return answer\n\nA = int(input())\n\nsolution(A)\n\n\n\n\n시간 초과가 나는 것은 DP를 이용한 메모이제이션 기법을 사용하지 않았기 때문이다.\n\n\n\n참고 자료 : 유튜브\n\n꾸준한 번식 피보나치 수열, 동적 프로그래밍 [코딩 테스트 Python]\n"
} ,
  
  {
    "title"    : "[Python] - 그래프 탐색 알고리즘 : DFS/BFS",
    "category" : "",
    "tags"     : " Python, CodingTest",
    "url"      : "/syntax/2023/01/30/Python-dfs-bfs.html",
    "date"     : "January 30, 2023",
    "excerpt"  : "그래프 탐색 알고리즘 : DFS/BFS\n\n\n  탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말한다.\n  대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있다.\n  DFS/BFS는 코딩 테스트에서 매우 자주 등장하는 유형이다.\n\n\n공부 전 알아야하는 자료구조\n\n1. 스택 (Stack) 자료구조\n\n\n  먼저 들어 온 데이터가 나중에 나가는 형식(선입후출 LIFO)의 자료구조\n  입구와 출구가 동일한 형태로...",
  "content"  : "그래프 탐색 알고리즘 : DFS/BFS\n\n\n  탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말한다.\n  대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있다.\n  DFS/BFS는 코딩 테스트에서 매우 자주 등장하는 유형이다.\n\n\n공부 전 알아야하는 자료구조\n\n1. 스택 (Stack) 자료구조\n\n\n  먼저 들어 온 데이터가 나중에 나가는 형식(선입후출 LIFO)의 자료구조\n  입구와 출구가 동일한 형태로 스택을 시각화할 수 있다.\n\n\n파이썬에서 스택을 구현할 때는 List를 사용한다.\n\n\n  append() 메소드를 통한 삽입\n  pop() 메소드를 통한 삭제를 구현할 수 있다.\n\n\nstack = []\n\n# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제()\n# 삽입(1) - 삽입(4) - 삭제()\n\nstack.append(5)\nstack.append(2)\nstack.append(3)\nstack.append(7)\nstack.pop()\n\nstack.append(1)\nstack.append(4)\nstack.pop()\n\nprint(stack[::-1]) # 최상단 원소부터 출력\nprint(stack) # 최하단 원소부터 출력\n\n# 실행 결과\n# [1, 3, 2, 5]\n# [5, 2, 3, 1]\n\n\n2. 큐 (Queue) 자료 구조\n\n\n  먼저 들어 온 데이터가 먼저 나가는 형식(선입선출 FIFO)의 자료구이다.\n  큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태로 시각화 할 수 있다.\n\n\n파이썬에서 큐(Queue)를 구현하기 위해서는 덱(deque) 라이브러리를 사용할 수 있다.\n\n\n  일반적으로 파이썬의 deque 라이브러리는 stack과 queue를 다 사용할 수 있다.\n  파이썬에서 큐(Queue)의 경우 적절한 자료형이 존재하지 않고, deque를 사용할 때, 시간적으로 우수하기 때문에 일반적으로 큐(Queue)를 구현할 때 deque를 사용한다.\n\n\nfrom collections import deque\n\n# 큐(Queue) 구현을 위해 deque 라이브러리 사용\nqueue = deque()\n\n# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제()\n# 삽입(1) - 삽입(4) - 삭제()\n\nqueue.append(5)\nqueue.append(2)\nqueue.append(3)\nqueue.append(7)\nqueue.popleft()\n\nqueue.append(1)\nqueue.append(4)\nqueue.popleft()\n\nprint(queue) # 먼저 들어온 순서대로 출력\nqueue.reverse() # 역순으로 바꾸기\nprint(queue) # 낮중에 들어온 원소부터 출력\n\n# 실행 결과\n# deque([3, 7, 1, 4])\n# deque([4, 1, 7, 3])\n\n\n재귀 함수\n\n\n  재귀 함수(Recursive Function)란 자기 자신을 다시 호출하는 함수를 의미\n  내부적으로 컴퓨터 시스템이 함수를 연속적으로 호출하게 되었을 때, 가장 마지막으로 호출된 함수가 처리가 되어야 그 이전에 호출된 함수가 처리가 되기 때문에 Stack과 굉장히 유사한 구조이므로 Stack이 필요할 때, Stack 라이브러리를 사용하지 않고 재귀 함수를 통해 Stack을 구현할 때도 많이 사용한다.\n  단순한 형태의 재귀 함수 예제\n    \n      ‘재귀 함수를 호출합니다.’ 라는 문자열을 무한히 출력한다.\n      어느 정도 출력하다가 최대 재귀 깊이 초과 메시지가 출력된다.\n    \n  \n\n\ndef recursive_function():\n\tprint(&#39;재귀 함수를 호출합니다.&#39;)\n\trecursive_function()\n\nrecursive_function()\n\n\n재귀 함수의 종료 조건\n\n\n  재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 한다.\n  종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있다.\n\n\n# 종료 조건을 포함한 재귀 함수 예제\n\ndef recursive_function(i):\n\t# 100번째 호출을 했을 때, 종료되도록 종료 조건 명시\n\tif i == 100:\n\t\treturn\n\tprint(i, &#39;번째 재귀함수에서&#39;, i + 1, &#39;번째 재귀함수를 호출합니다.&#39;)\n\trecursive_function(i + 1)\n\tprint(i, &#39;번째 재귀함수를 종료합니다.&#39;)\n\nrecursive_function(1)\n\n\n팩토리얼 구현 예제\n\n\n  n! = 1 x 2 x 3 x … x (n - 1) x n\n  수학적으로 0!과 1!의 값은 1이다.\n\n\n# 반복적으로 구현한 n!\ndef factorial_iterative(n):\n\tresult = 1\n\t# 1부터 n까지의 수를 차례대로 곱하기\n\tfor i in range(1, n + 1):\n\t\tresult *= i\n\treturn result\n\n# 재귀적으로 구현한 n!\ndef factorial_recursive(n):\n\tif n &amp;lt;= 1: # n이 1이하인 경우 1을 반환\n\t\treturn 1\n\t# n! = n * (n - 1)!를 그대로 코드로 작성하기\n\treturn n * factorial_recursive(n - 1)\n\n# 각각의 방식으로 구현한 n! 출력 (n = 5)\nprint(&#39;반복적으로 구현:&#39;, factorial_iterative(5))\nprint(&#39;재귀적으로 구현:&#39;, factorial_recursive(5))\n\n# 실행 결과\n# 반복적으로 구현: 120\n# 재귀적으로 구현: 120\n\n\nDFS(Depth-First Search)\n\n\n  DFS는 깊이 우선 탐색이라고도 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.\n  DFS는 스택 자료구조(혹은 재귀 함수)를 이용하며, 구체적인 동작 과정은 다음과 같다.\n    \n      탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.\n      스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.\n      더 이상 2번의 과정을 수행할 수 없을 때까지 반복한다.\n    \n  \n\n\nDFS 소스코드 예제\n\n# DFS 메서드 정의\ndef dfs(graph, v, visited):\n\t# 현재 노드를 방문 처리\n\tvisited[v] = True\n\tprint(v, end = &#39; &#39;)\n\t# 현재 노드와 연결된 다른 노드를 재귀적으로 방문\n\tfor i in graph[v]:\n\t\tif not visited[i]:\n\t\t\tdfs(graph, i, visited)\n\n# 각 노드가 연결된 정보를 표현 (2차원 리스트)\ngraph = [\n\t[],\n\t[2, 3, 8],\n\t[1, 7],\n\t[1, 4, 5],\n\t[3, 5],\n\t[3, 4],\n\t[7],\n\t[2, 6, 8],\n\t[1, 7],\t\n]\n\n# 각 노드가 방문된 정보를 표현 (1차원 리스트)\nvisited = [False] * 9\n\n# 정의된 DFS 함수 호출\ndfs(graph, 1, visited)\n\n# 실행 결과\n# 1 2 7 6 8 3 4 5\n\n\nBFS (Breadth-First Search)\n\n\n  BFS는 너비 우선 탐색이라고도 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘이다.\n  BFS는 큐 자료구조를 이용하며, 구체적인 동작 과정은 다음과 같다.\n    \n      탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.\n      큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.\n      더 이상 2번의 과정을 수행할 수 없을 때까지 반복한다.\n    \n  \n\n\nfrom collections import deque\n\n# BFS 메서드 정의\ndef bfs(graph, start, visited):\n\t# 큐 (Queue) 구현을 위해 deque 라이브러리 사용\n\tqueue = deque([start])\n\t# 현재 노드를 방문 처리\n\tvisited[start] = True\n\t# 큐가 빌 때까지 반복\n\twhile queue:\n\t\t# 큐에서 하나의 원소를 뽑아 출력하기\n\t\tv = queue.popleft()\n\t\tprint(v, end=&#39; &#39;)\n\t\t# 아직 방문하지 않은 인접한 원소들을 큐에 삽입\n\t\tfor i in graph[v]:\n\t\t\tif not visited[i]:\n\t\t\t\tqueue.append(i)\n\t\t\t\tvisited[i] = True\n\n# 각 노드가 연결된 정보를 표현 (2차원 리스트)\ngraph = [\n\t[],\n\t[2, 3, 8],\n\t[1, 7],\n\t[1, 4, 5],\n\t[3, 5],\n\t[3, 4],\n\t[7],\n\t[2, 6, 8],\n\t[1, 7]\n]\n\n# 각 노드가 방문된 정보를 표현 (1차원 리스트)\nvisited = [False] * 9\n\n# 정의된 BFS 함수 호출\nbfs(graph, 1, visited)\n\n# 실행 결과\n# 1 2 3 8 7 4 5 6\n\n\n\n\n&amp;lt;DFS / BFS 코딩테스트 문제&amp;gt;\n\n무인도 여행\n\n\n  \n     프로그래머스 : [https://school.programmers.co.kr/learn/courses/30/lessons/154540](https://school.programmers.co.kr/learn/courses/30/lessons/154540)\n\n\n  \n\n문제 설명\n\n메리는 여름을 맞아 무인도로 여행을 가기 위해 지도를 보고 있습니다. 지도에는 바다와 무인도들에 대한 정보가 표시돼 있습니다. 지도는 1 x 1크기의 사각형들로 이루어진 직사각형 격자 형태이며, 격자의 각 칸에는 ‘X’ 또는 1에서 9 사이의 자연수가 적혀있습니다. 지도의 ‘X’는 바다를 나타내며, 숫자는 무인도를 나타냅니다. 이때, 상, 하, 좌, 우로 연결되는 땅들은 하나의 무인도를 이룹니다. 지도의 각 칸에 적힌 숫자는 식량을 나타내는데, 상, 하, 좌, 우로 연결되는 칸에 적힌 숫자를 모두 합한 값은 해당 무인도에서 최대 며칠동안 머물 수 있는지를 나타냅니다. 어떤 섬으로 놀러 갈지 못 정한 메리는 우선 각 섬에서 최대 며칠씩 머물 수 있는지 알아본 후 놀러갈 섬을 결정하려 합니다.\n\n지도를 나타내는 문자열 배열 maps가 매개변수로 주어질 때, 각 섬에서 최대 며칠씩 머무를 수 있는지 배열에 오름차순으로 담아 return 하는 solution 함수를 완성해주세요. 만약 지낼 수 있는 무인도가 없다면 -1을 배열에 담아 return 해주세요.\n\n제한사항\n\n\n  3 ≤ maps의 길이 ≤ 100\n    \n      3 ≤ maps[i]의 길이 ≤ 100\n      maps[i]는 ‘X’ 또는 1 과 9 사이의 자연수로 이루어진 문자열입니다.\n      지도는 직사각형 형태입니다.\n    \n  \n\n\n입출력 예\n\n\n  \n    \n      maps\n      result\n    \n  \n  \n    \n      [“X591X”,”X1X5X”,”X231X”, “1XXX1”]\n      [1, 1, 27]\n    \n    \n      [“XXX”,”XXX”,”XXX”]\n      [-1]\n    \n  \n\n\n입출력 예 설명\n\n입출력 예 #1\n\n위 문자열은 다음과 같은 지도를 나타냅니다.\n\n\n\n연결된 땅들의 값을 합치면 다음과 같으며\n\n\n\n이를 오름차순으로 정렬하면 [1, 1, 27]이 됩니다.\n\n입출력 예 #2\n\n위 문자열은 다음과 같은 지도를 나타냅니다.\n\n\n\n섬이 존재하지 않기 때문에 -1을 배열에 담아 반환합니다.\n\n풀이 코드\n\nfrom collections import deque\n\ndx, dy = [1, -1, 0, 0], [0, 0, -1, 1]\n\ndef solution(maps):\n    answer = []\n    a, b = len(maps), len(maps[0])\n    visit = [[False] * b for _ in range(a)]\n    \n    def bfs(x, y):\n        queue = deque();\n        queue.append((x, y))\n        bfs_result = int(maps[x][y])\n        \n        while queue:\n            current_x, current_y = queue.popleft()\n            \n            for l in range(4):\n                next_x = dx[l] + current_x\n                next_y = dy[l] + current_y\n                \n                if next_x &amp;lt; 0 or next_x &amp;gt;= a or next_y &amp;lt; 0 or next_y &amp;gt;= b:\n                    continue\n                    \n                if not visit[next_x][next_y] and maps[next_x][next_y] != &#39;X&#39;:\n                    queue.append((next_x, next_y)) \n                    visit[next_x][next_y] = True\n                    bfs_result += int(maps[next_x][next_y])\n            \n        return bfs_result\n    \n    for i in range(a):\n        for j in range(b):\n            if maps[i][j] != &#39;X&#39; and not visit[i][j]:\n                visit[i][j] = True\n                answer.append(bfs(i,j))\n    \n    return sorted(answer) if answer else [-1]\n\n\n음료수 얼려 먹기\n\n\n  \n      이것이 취업을 위한 코딩 테스트다 with 파이썬 (동영상 59:39) : [https://www.youtube.com/watch?v=PqzyFDUnbrY&amp;amp;list=PLRx0vPvlEmdBFBFOoK649FlEMouHISo8N&amp;amp;index=3](https://www.youtube.com/watch?v=PqzyFDUnbrY&amp;amp;list=PLRx0vPvlEmdBFBFOoK649FlEMouHISo8N&amp;amp;index=3)\n\n\n  \n\n문제 설명\n\nN x M 크기의 얼음 틀이 있습니다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시됩니다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주합니다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하세요. 다음의 4 x 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성됩니다.\n\n입출력 예\n\n\n  입력 예 #1\n4 5\n00110\n00011\n11111\n00000\n출력 예 #1\n3\n\n\n\ndef validationResult(result):\n    if result == 3:\n        return True\n    else:\n        return False\n\ndx, dy = [0, 0, 1, -1],[-1, 1, 0, 0]\n\ndef solution(maps):\n    answer = 0\n    a, b = len(maps), len(maps[0])\n    visit = [[False] * b for _ in range(a)]\n\n    def dfs(x, y):\n        if x &amp;lt;= -1 or x &amp;gt;= a or y &amp;lt;= -1 or y &amp;gt;= b:\n            return False\n\n        if maps[x][y] == &#39;0&#39; and not visit[x][y]:\n            visit[x][y] = True\n            dfs(x, y-1)\n            dfs(x-1, y)\n            dfs(x, y+1)\n            dfs(x+1, y)\n            return True\n\n        return False\n\n    for i in range(a):\n        for j in range(b):\n            if dfs(i,j):\n                answer += 1\n    print(&#39;answer&#39;,answer)\n\n    return answer\n\ngraph = [&#39;00110&#39;,&#39;00011&#39;,&#39;11111&#39;,&#39;00000&#39;]\n\nresult = solution(graph)\nprint(&#39;result&#39;,result)\nvalidity_result = validationResult(result)\n\nif validity_result:\n    print(&#39;정답&#39;)\nelse:\n    print(&#39;오답&#39;)\n\n"
} ,
  
  {
    "title"    : "React Query + 상태 + 상태 관리 [2편]",
    "category" : "",
    "tags"     : " React, ReactNative, State, StateManagement",
    "url"      : "/syntax/2023/01/13/ReactQuery-State-StateManagement-02.html",
    "date"     : "January 13, 2023",
    "excerpt"  : "React Query + 상태 + 상태 관리 [2편]\n\n\n  이 글은 유튜브 영상 중 ‘React Query와 상태관리’ 라는 주제로 2022.02 우아한테크세미나의\n영상을 보며 공부를 하고 정리한 내용을 바탕으로 기술되었습니다. 저의 주관이 섞인 내용이 들어갈 수도 있고,\n영상에서 다루는 내용을 정리하여 기록한 내용이 주로 다루어집니다.\n\n\nReact Query\n\n\n🌱 DataBase에서 가져온 데이터를 클라이언트에서 보여주기 위해 개발...",
  "content"  : "React Query + 상태 + 상태 관리 [2편]\n\n\n  이 글은 유튜브 영상 중 ‘React Query와 상태관리’ 라는 주제로 2022.02 우아한테크세미나의\n영상을 보며 공부를 하고 정리한 내용을 바탕으로 기술되었습니다. 저의 주관이 섞인 내용이 들어갈 수도 있고,\n영상에서 다루는 내용을 정리하여 기록한 내용이 주로 다루어집니다.\n\n\nReact Query\n\n\n🌱 DataBase에서 가져온 데이터를 클라이언트에서 보여주기 위해 개발자는 ajax를 이용하는데, 이 때 서버에서 가져오는 데이터를 `Server State` 라고 한다.\n\n\n\n\n  React Query는 서버에서 가져온 데이터를 웹 브라우저 앱에서 사용하기 쉽게 도와주는 기술이다.\n    \n      데이터 가져오기 (fetching)\n      캐시 (caching)\n      동기화 (synchronizing)\n      데이터 업데이트 (updating server state)\n    \n  \n\n\nReact Query 공식 예제 Code\n\nimport {QueryClient, QueryClientProvider, useQuery} from &#39;react-query&#39;;\n\nconst queryClient = new QueryClient()\n\nexport default function App(){\n\treturn(\n\t\t&amp;lt;QueryClientProvider client={queryClient}&amp;gt;\n\t\t\t&amp;lt;Example /&amp;gt;\n\t\t&amp;lt;/QueryClientProvider&amp;gt;\n\t)\n}\n\nfunction Example(){\n\tconst { isLoading, error, data } = useQuery(&#39;repoData&#39;, () =&amp;gt;\n\t\tfetch(&#39;https://api.github.com/repos/tannerlinsley/react-query&#39;).then(res =&amp;gt;\n\t\t\tres.json()\n\t\t)\n\t)\n\n\tif (isLoading) return &#39;Loading...&#39;\n\n\tif (error) return &#39;An error has occureed: &#39; + error.message\n\n\treturn (\n\t\t&amp;lt;div&amp;gt;\n\t\t\t&amp;lt;h1&amp;gt;{data.name}&amp;lt;/h1&amp;gt;\n\t\t\t&amp;lt;p&amp;gt;{data.description}&amp;lt;/p&amp;gt;\n       &amp;lt;strong&amp;gt;👀 {data.subscribers_count}&amp;lt;/strong&amp;gt;{&#39; &#39;}\n       &amp;lt;strong&amp;gt;✨ {data.stargazers_count}&amp;lt;/strong&amp;gt;{&#39; &#39;}\n       &amp;lt;strong&amp;gt;🍴 {data.forks_count}&amp;lt;/strong&amp;gt;\n\t\t&amp;lt;/div&amp;gt;\n\t)\n}\n\n\n\nReact Query와 상태관리\n\n세 가지 core 컨셉 살펴보기\n\n공식 문서 Quick Start에서 짚은 3가지의 개념\n\n\n  Queries\n  Mutations\n  Query Invalidation\n\n\nQueries\n\n보통 GET으로 받아올 대부분의 API를 사용\n\n\n  Queries는 데이터 Fetching용이다.\n  CRUD중 Reading에 사용한다.\n\n\nimport { useQuery } from &#39;react-query&#39;\n\nfunction App() {\n\tconst info = useQuery(&#39;todos&#39;, fetchTodoList)\n}\n\n/*\n* useQuery() arguments\n* first arg - Query Key\n* second arg - Query Function\n* third arg - Query Option\n*/\n\n\nQuery Key\n\nkey, value 맵핑 구조를 생각하면 된다.\n\n\n  React Query는 Query Key에 따라 query caching을 관리한다.\n\n\nString 형태\n\n// A list of todos\nuseQuery(&#39;todos&#39;, ...) // queryKey === (&#39;todos&#39;)\n\n// Something else, whatever\nuseQuery(&#39;somethingSpecial&#39;, ...) // queryKey === (&#39;somethingSpecial&#39;)\n\n\nArray 형태 - 실질적으로 pagination이나 각종 옵션을 줄때\n\n// An individual todo\nuseQuery([&#39;todos&#39;, 5], ...)\n// queryKey === [&#39;todos&#39;, 5]\n\n// An individual todo in a &quot;preview&quot; format\nuseQuery([&#39;todos&#39;, 5, { preview: true}], ...)\n//queryKey === [&#39;todos&#39;, 5, { preview: true}]\n\n// A list of todos that are &quot;done&quot;\nuseQuery([&#39;todos&#39;, { type: &#39;done&#39; }], ...)\n//queryKey === [&#39;todos&#39;, { type: &#39;done&#39; }]\n\n\nQuery Function\n\nData Fetching, Promise\n\n\n  Promise를 반환하는 함수 → 데이터를 resolve하거나 error를 throw\n  fetch, axios 등 데이터를 fetching하는 함수가 들어간다.\n\n\nuseQuery가 반환하는 return 값\n\n\n  data: 마지막으로 성공한 resolved된 데이터 (Response)\n  error: 에러가 발생했을 때 반환되는 객체\n  isFetching: Request가 in-flight(진행중) 중일 때 true\n  status, isLoading, isSuccess, isLoadingError 등등: 모두 현재 query의 상태\n  refetch: 해당 query refetch하는 함수 제공\n  remove: 해당 query cache에서 지우는 함수 제공\n\n\n등 을 제공한다.\n\nuseQuery Option\n\n\n  onSuccess, onError, onSettled: query fetching 성공/실패/완료 시 실행할 Side Effect 정의\n  enabled: 자동으로 query를 실행시킬지 말지 여부\n  retry: query 동작 실패 시, 자동으로 retry 할지 결정하는 옵션\n  select: 성공 시 가져온 data를 가공해서 전달\n  keepPreviousData: 새롭게 fetching 시 이전 데이터 유지 여부\n  refetchInterval: 주기적으로 refetch 할지 결정하는 옵션 (폴링 구현할 일이 있을 때)\n\n\n등\n"
} ,
  
  {
    "title"    : "React Query + 상태 + 상태 관리 [1편]",
    "category" : "",
    "tags"     : " React, ReactNative, State, StateManagement",
    "url"      : "/syntax/2023/01/13/ReactQuery-State-StateManagement-01.html",
    "date"     : "January 13, 2023",
    "excerpt"  : "React Query + 상태 + 상태 관리 [1편]\n\n\n  이 글은 유튜브 영상 중 ‘React Query와 상태관리’ 라는 주제로 2022.02 우아한테크세미나의\n영상을 보며 공부를 하고 정리한 내용을 바탕으로 기술되었습니다. 저의 주관이 섞인 내용이 들어갈 수도 있고,\n영상에서 다루는 내용을 정리하여 기록한 내용이 주로 다루어집니다.\n\n\n우선적으로 React Query에 이야기를 하시기 전에 상태에 관한 이야기로 세미나의 서두를 띄우...",
  "content"  : "React Query + 상태 + 상태 관리 [1편]\n\n\n  이 글은 유튜브 영상 중 ‘React Query와 상태관리’ 라는 주제로 2022.02 우아한테크세미나의\n영상을 보며 공부를 하고 정리한 내용을 바탕으로 기술되었습니다. 저의 주관이 섞인 내용이 들어갈 수도 있고,\n영상에서 다루는 내용을 정리하여 기록한 내용이 주로 다루어집니다.\n\n\n우선적으로 React Query에 이야기를 하시기 전에 상태에 관한 이야기로 세미나의 서두를 띄우셨다.\n\n상태란 ?\n\n\n  주어진 시간(시간에 따라서 언제든지 변화할 수 있음)에 대해 시스템을 나타내는 것으로 언제든지 변경될 수 있고, 즉 문자열, 배열, 객체 등의 형태로 응용 프로그램에 저장된 데이터 + 개발자 입장에서 관리해야하는 데이터\n  UI/UX의 중요성과 함께 프로덕트 규모가 많이 커지고 Front-end에서 수행하는 역할이 늘어났다 → 관리해야 하는 상태가 많아졌다.\n\n\nFE(Front-End) 상태관리는?\n\n\n  보통 상태 관리가 무엇인가요? 라는 질문을 받으면 추상적인 개념으로 라이브러리가 먼저 떠오른다.\n    \n      Redux, MobxX, Recoil 등\n    \n  \n  그리고 React의 useState Hook도 떠오를 수 있고, 어떠한 웹 객체 요소의 현재 상태(닫혀 있는 상태, 열려있는 상태)도 이야기할 수 있을 것 같고, 데이터(Server State, Client State)가 변화하여 해당하는 데이터를 Re-render 하거나 저장하고, 변경하는 작업 등도 떠오르게 되는 것 같다.\n\n\n그래서 상태관리가 무엇인데?\n\n\n  상태를 관리하는 방법에 대한 것 → 프로덕트가 커짐에 따라 상태를 관리하는 어려움도 커진다.\n    \n      이유 : 프로덕트 크기가 클 수록 관리가 필요한 상태가 많아지고, 그 상태는 언제든지 변경될 수 있기 떄문\n    \n  \n  React에서는 단방향 바인딩이므로 부모 컴포넌트에서 하위 컴포넌트까지 필요한 상태를 전달해주기 위함이나 관계적으로는 더 먼 곳에 있는 컴포넌트에 해당 데이터를 전달하기 위한 Props Drilling 이슈도 존재\n  위와 같은 Props Drilling이라는 이슈를 해결하고 더 나은 상태 관리 환경을 위한 Redux와 MobX 같은 라이브러리를 활용해서 해당 이슈를 해결하고, 상태를 전역적으로 관리하기도 한다.\n  이처럼 상태를 어떻게 Handle 하는지를 통 틀어서 상태 관리라고 말할 수 밖에 없을 것 같다.\n\n\n\n  정리하자면 모던 웹 프론트 환경에서는 여러 가지 상태들이 존재하고, 그 상태들을 체계적으로 관리하기 위한 여러가지 상태 관리 정돈 방식이 등장했다 라고 정리할 수 있다.\n\n\n\n상태(state)의 Ownership에 따라 관리 포인트를 나눈다.\n\nClient State ? Server State?\n\n\n  Key Point는 데이터의 Ownership이 있는 곳\n\n\n\nClient State - Ownership이 Client에 있다.\n\n\n  Client에서 소유하며 온전히 제어가능하다.\n  초기값 설정이나 조작에 제약사항 없음\n  다른 사람들과 공유되지 않으며 Client 내에서 UI/UX 흐름이나 사용자 인터렉션에 따라 변할 수 있다.\n  항상 Client 내에서 최신 상태로 관리된다.\n\n\nServer State - Ownership이 Server에 있다.\n\n\n  Client에서 제어하거나 소유되지 않은 원격의 공간에서 관리되고 유지된다.\n  Fetching/Updating에 비동기 API가 필요하다.\n  다른 사람들과 공유되는 것으로 사용자가 모르는 사이에 변경될 수 있다.\n  신경 쓰지 않는다면 잠재적으로 “out of date”가 될 가능성을 지니고 있다.\n\n"
} ,
  
  {
    "title"    : "[Code refactoring] - 원티드 프리온보딩 프론트엔드 챌린지 - 사전과제 리팩토링",
    "category" : "",
    "tags"     : " React, Refactoring, CodeReview",
    "url"      : "/syntax/2023/01/11/Wanted-pre-onboarding-01.html",
    "date"     : "January 11, 2023",
    "excerpt"  : "원티드에서 프리온보딩 프론트엔드 챌린지를 참여하고 있다.\n\n라이브 세션에 참가하신 개발자 분들이 500명이 넘어서 설마 내 코드가 리뷰되겠어? 라는 생각이 있었는데\n\n사전 과제로 제출한 코드 중 유저의 토큰을 관리하는 코드에 관해 멘토님이 리뷰를 진행해주셨다.\n\n멘토님이 리뷰 주신 코드\n\n\n  path : modules/auth/authValidation.tsx\n\n\nexport const getUserInfomation = async ()...",
  "content"  : "원티드에서 프리온보딩 프론트엔드 챌린지를 참여하고 있다.\n\n라이브 세션에 참가하신 개발자 분들이 500명이 넘어서 설마 내 코드가 리뷰되겠어? 라는 생각이 있었는데\n\n사전 과제로 제출한 코드 중 유저의 토큰을 관리하는 코드에 관해 멘토님이 리뷰를 진행해주셨다.\n\n멘토님이 리뷰 주신 코드\n\n\n  path : modules/auth/authValidation.tsx\n\n\nexport const getUserInfomation = async () =&amp;gt; {\n    let getUserInfoResult = {\n        success: false,\n        email: &#39;&#39;,\n        token: &#39;&#39;,\n    }\n    let emailResult = await localStorage.getItem(&#39;email&#39;);\n    let tokenResult = await localStorage.getItem(&#39;token&#39;);\n\n    if(emailResult &amp;amp;&amp;amp; tokenResult){\n        getUserInfoResult.email = emailResult;\n        getUserInfoResult.token = tokenResult;\n        getUserInfoResult.success = true;\n    }\n\n    return getUserInfoResult;\n}\n\n\n\n  부끄럽게도 벌써 실수가 눈에 보인다\n얼마전까지 React Native를 공부하면서 ‘Async Storage’를 공부했는데\nlocalStorage에 비동기 작업을 걸려고 await를 사용하는 아주 기초적인 실수를 해버린 것;;🫠\n구현하고 제출하느라 정신 없어서 눈치를 못채고 제출했더니 이런 실수를 그대로 제출했다니..\n\n\n저걸 라이브 세션에서 보고는 어질 어질했다..\n\n하지만 실수를 했으면 고쳐야 하는 것\n\n멘토님이 주신 해당 코드의 피드백)\n\n  get- 접두사 → 동사인가?\n  localStorage는 비동기일까? → 함수의 색(color) 문제 (https://willowryu.github.io/2021-05-21/)\n\n\n그리고 해당 소스를 더 가독성 좋게 리팩토링 하는 것을 직접 보여주셨다.\n\n\n\n\n리팩토링\n\n\n  해당 소스에서 크게 문제가 되는 점은 멘토님이 피드백 주신 두 가지\n    \n      localStorage는 비동기인가?\n      \n        해당 모듈의 네이밍이 적절한가?\n\n        \n          우선 localStorage의 모든 작업은 동기적으로 이루어진다.\n그렇기 때문에 비동기로 사용하려던 내용을 수정하고 해당 부분의 코드가 수정이 필요하다.\n        \n\n        해당 모듈의 네이밍이 적절한가?\n항상 함수나 변수 이름 작명은 많은 고민을 낳는 것 같다..\n우선 ’get’ 을 떠올릴 때 무엇인가를 얻어온다 라는 느낌까지는 괜찮은데\n지금 다시 보니까 API를 호출할거 같은 느낌이 든다.\n\n        그리고 멘토님의 리팩토링 과정을 보고 좀 더 간결하게 코드를 작성할 수 있을 것 같다.\n        \n\n        \n      \n    \n  \n  정리가 된 코드\n\n\nexport const getUserInfomation = () =&amp;gt; {\n\t\tconst email = localStorage.getItem(&#39;email&#39;);\n\t\tconst token = localStorage.getItem(&#39;token&#39;);\n\n\t\tconst conditions = [email, token]\n\n\t\tif(conditions.every(condition =&amp;gt; !!condition)) {\n\t\t\treturn {\n        success: true,\n        email,\n        token,\n\t    }\n\t\t}\n\n    return {\n        success: false,\n        email: &#39;&#39;,\n        token: &#39;&#39;,\n    }\n}\n\n\n\n  비동기 사용을 위한 async await 를 코드에서 덜어내고,\n\n\nlocalStorage에서 해당 값의 정보를 가져오는 부분을 모듈 상단 부로 이동\n\narray에 localStorage에서 받아온 결과를 넣고,\n\ntoken과 email 값의 검사를 **Array.prototype.every() 를 통해 테스트한다.\nBoolean 값을 반환하기 때문에 if 문을 통해 해당 모듈에서 반환을 해주기 위한\n결과 값들을 바로 반환하여 줄 수 있다.\n\n구현 후 리팩토링에도 정말 많은 신경을 쓰도록 노력해봐야겠다.**\n\n\n\n"
} ,
  
  {
    "title"    : "[Python] - 문자열 자료형, 튜플 자료형",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/10/Python-string-tuple.html",
    "date"     : "January 10, 2023",
    "excerpt"  : "문자열 자료형\n\n\n  문자열 변수를 초기화할 때는 큰 따옴표(”)나 작은 따옴표(’)를 이용한다.\n  문자열 안에 큰 따옴표나 작은 따옴표가 포함되어야 하는 경우가 있다.\n    \n      전체 문자열을 큰 따옴표로 구성하는 경우, 내부적으로 작은 따옴표를 포함할 수 있다.\n      전체 문자열을 작은 따옴표로 구성하는 경우, 내부적으로 큰 따옴표를 포함할 수 있다.\n      혹은 백슬래시()를 사용하면, 큰 따옴표나 작은 따옴표를 ...",
  "content"  : "문자열 자료형\n\n\n  문자열 변수를 초기화할 때는 큰 따옴표(”)나 작은 따옴표(’)를 이용한다.\n  문자열 안에 큰 따옴표나 작은 따옴표가 포함되어야 하는 경우가 있다.\n    \n      전체 문자열을 큰 따옴표로 구성하는 경우, 내부적으로 작은 따옴표를 포함할 수 있다.\n      전체 문자열을 작은 따옴표로 구성하는 경우, 내부적으로 큰 따옴표를 포함할 수 있다.\n      혹은 백슬래시()를 사용하면, 큰 따옴표나 작은 따옴표를 원하는 만큼 포함시킬 수 있다. - escape 문법을 이용\n    \n  \n\n\ndata = &#39;Hello World&#39;\nprint(data)\n# 실행 결과 : Hello World\n\ndata = &quot;Don&#39;t you know \\&quot;Python\\&quot;?&quot;\nprint(data)\n# 실행 결과 : Don&#39;t you know &quot;Python&quot;?\n\n\n문자열 연산\n\n\n  문자열 변수에 덧셈(+)을 이용하면 문자열이 더해져서 연결(Concatenate)된다.\n  문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해진다.\n  문자열에 대해서도 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있다.\n    \n      다만 문자열은 특정 인덱스의 값을 변경할 수는 없다. (Immutable : 불변성)\n    \n  \n\n\na = &quot;Hello&quot;\nb = &quot;World&quot;\nprint(a + &quot; &quot; + b)\n# 실행 결과 : Hello World\n\na = &quot;String&quot;\nprint(a * 3)\n# 실행 결과 : StringStringString\n\na = &quot;ABCDEF&quot;\nprint(a[2 : 4])\n# 실행 결과 : CD\n\n\n튜플 자료형\n\n\n  튜플 자료형은 리스트와 유사하지만 다음과 같은 문법적인 차이가 있다.\n    \n      튜플은 한 번 선언된 값을 변경할 수 없다.\n      리스트는 대괄호([])를 이용하지만, 튜플은 소괄호(())를 이용한다.\n    \n  \n  튜플은 리스트에 비해 상대적으로 공간 효율적이다.\n\n\na = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n# 네 번째 원소만 출력\nprint(a[3])\n# 실행 결과 : 4\n\n# 두 번째 원소부터 네 번째 원소까지\nprint(a[1 : 4])\n# 실행 결과 : (2, 3, 4)\n\n\n\n  튜플 사용 중 오류가 발생하는 예제\n\n\na = (1, 2, 3, 4)\nprint(a)\n# 실행 결과 (1, 2, 3, 4)\n\n# a의 인덱스 2번지에 7로 값 변경 시도\na[2] = 7\n\n# 실행 결과 Error!\n\n\n\n\n튜플을 사용하면 좋은 경우\n\n\n  서로 다른 성질의 데이터를 묶어서 관리해야 할 때\n    \n      최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용한다.\n    \n  \n  데이터의 나열을 해싱(Hashing)의 키 값으로 사용해야 할 때\n    \n      튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다.\n    \n  \n  리스트보다 메모리를 효율적으로 사용해야 할 때\n\n"
} ,
  
  {
    "title"    : "[Python] - 조건문, 반복문",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/10/Python-if-for-while.html",
    "date"     : "January 10, 2023",
    "excerpt"  : "조건문\n\n\n  조건문은 프로그램의 흐름을 제어하는 문법이다.\n  조건문을 이용해 조건에 따라서 프로그램의 로직을 설정할 수 있다.\n\n\nx = 15\n\nif x &amp;gt;= 10:\n\tprint(&quot;x &amp;gt;= 10&quot;)\n\nif x &amp;gt;= 0:\n\tprint(&quot;x &amp;gt;= 0&quot;)\n\nif x &amp;gt;= 30:\n\tprint(&quot;x &amp;gt;= 30&quot;)\n\n# 실행 결과 )\n# x &amp;gt;= 10\n# x &amp;gt;= 0\n\n\n들여쓰기\n\n\n  파이썬에서는 코드...",
  "content"  : "조건문\n\n\n  조건문은 프로그램의 흐름을 제어하는 문법이다.\n  조건문을 이용해 조건에 따라서 프로그램의 로직을 설정할 수 있다.\n\n\nx = 15\n\nif x &amp;gt;= 10:\n\tprint(&quot;x &amp;gt;= 10&quot;)\n\nif x &amp;gt;= 0:\n\tprint(&quot;x &amp;gt;= 0&quot;)\n\nif x &amp;gt;= 30:\n\tprint(&quot;x &amp;gt;= 30&quot;)\n\n# 실행 결과 )\n# x &amp;gt;= 10\n# x &amp;gt;= 0\n\n\n들여쓰기\n\n\n  파이썬에서는 코드의 블록(Blcok)을 들여쓰기(Indent)로 지정한다.\n  다음의 코드에서 (2)번 라인은 무조건 실행된다.\n\n\nscore = 85\n\nif score &amp;gt;= 70:\n\tprint(&quot;성적이 70점 이상입니다.&quot;)\n\tif score &amp;gt;= 90:\n\t\tprint(&quot;우수한 성적입니다.&quot;)\nelse: \n\tprint(&quot;성적이 70점 미만입니다.&quot;) #(1)\n\tprint(&quot;조금 더 분발하세요.&quot;) #(1)\n\nprint(&quot;프로그램을 종료합니다.&quot;) #(2)\n\n# 실행 결과 )\n# 성적이 70점 이상입니다.\n# 프로그램을 종료합니다.\n\n\n\n  탭을 사용하는 진영과 공백 문자(space)를 여러 번 사용하는 진영이 나누어져 있지만\n  파이썬 스타일 가이드라인에서는 4개의 공백 문자를 사용하는 것을 표준으로 설정하고 있다.\n\n\n조건문의 기본 형태\n\n\n  조건문의 기본 형태는 if ~ elif ~ else 이다.\n    \n      조건문을 사용할 때 elif 혹은 else 부분은 경우에 따라서 사용하지 않아도 된다.\n    \n  \n\n\nif 조건문 1:\n\t조건문 1이 True일 때 실행되는 코드\nelif 조건문 2:\n\t조건문 1에 해당되지 않고, 조건문 2가 True일 때 실행되는 코드\nelse:\n\t\t위의 모든 조건문이 모두 True 값이 아닐 때 실행되는 코드\n\n\na = 5\n\nif a &amp;gt;= 0:\n\tprint(&quot;a &amp;gt;= 0&quot;)\nelif a &amp;gt;= -10:\n\tprint(&quot;0 &amp;gt; a &amp;gt;= -10&quot;)\nelse:\n\tprint(&quot;-10 &amp;gt; a&quot;)\n\n# 실행 결과 : a &amp;gt;= 0\n\n\n비교 연산자\n\n\n  비교 연산자는 특정한 두 값을 비교할 때 이용할 수 있다.\n\n\n\n  \n    \n      비교 연산자\n      설명\n    \n  \n  \n    \n      X == Y\n      X와 Y가 서로 같을 때 참(True)이다\n    \n    \n      X ≠ Y\n      X와 Y가 서로 다를 때 참(True)이다\n    \n    \n      X &amp;gt; Y\n      X가 Y보다 클 때 참(True)이다\n    \n    \n      X &amp;lt; Y\n      X가 Y보다 작을 때 참(True)이다\n    \n    \n      X ≥ Y\n      X가 Y보다 크거나 같을 때 참(True)이다\n    \n    \n      X ≤ Y\n      X가 Y보다 작거나 같을 때 참(True)이다\n    \n  \n\n\n논리 연산자\n\n\n  논리 연산자는 논리 값(True/False) 사이의 연산을 수행할 때 사용한다.\n\n\n\n  \n    \n      논리 연산자\n      설명\n    \n  \n  \n    \n      X and Y\n      X와 Y가 모두 참(True)일 때 참(True)이다.\n    \n    \n      X or Y\n      X와 Y중에 하나만 참(True)이어도 참(True)이다.\n    \n    \n      not X\n      X가 거짓(False)일 때 참(True)이다.\n    \n  \n\n\n파이썬의 기타 연산자\n\n\n  다수의 데이터를 담는 자료형을 위해 in 연산자와 not in 연산자가 제공된다.\n    \n      리스트, 튜플, 문자열, 딕셔너리 모두에서 사용 가능하다.\n    \n  \n\n\n\n  \n    \n      in 연산자와 not in 연산자\n      설명\n    \n  \n  \n    \n      x in 리스트\n      리스트 안에 x가 들어가 있을 때 참(True)이다.\n    \n    \n      x not in 문자열\n      문자열 안에 x가 들어가 있지 않을 때 참(True)이다.\n    \n  \n\n\n파이썬의 pass 키워드\n\n\n  아무것도 처리하고 싶지 않을 때 pass 키워드를 사용한다.\n  예시 ) 디버깅 과정에서 일단 조건문의 형태만 만들어 놓고 조건문을 처리하는 부분은 비워놓고 싶은 경우\n\n\nscore = 85\n\nif score &amp;gt;= 80:\n\tpass # 나중에 작성할 소스코드\nelse:\n\tprint(&quot;성적이 80점 미만입니다.&quot;)\n\nprint(&quot;프로그램을 종료합니다.&quot;)\n\n# 실행 결과 : 프로그램을 종료합니다.\n\n\n조건문의 간소화\n\n\n  조건문에서 실행될 소스코드가 한 줄인 경우, 굳이 줄 바꿈을 하지 않고도 간략하게 표현할 수 있다.\n\n\nscore = 85\n\nif score &amp;gt;= 80: result = &quot;Success&quot;\nelse: result = &quot;Fail&quot;\n\n# 실행 결과 : Success\n\n\n\n  조건부 표현식(Conditional Expression)은 if ~ else문을 한 줄에 작성할 수 있도록 해준다.\n\n\nscore = 85\n\nresult = &quot;Success&quot; if score &amp;gt;= 80 else &quot;Fail&quot;\n\nprint(reuslt)\n\n# 실행 결과 : Success\n\n\n파이썬 조건문 내에서의 부등식\n\n\n  다른 프로그래밍 언어와 다르게 파이썬은 조건문 안에서 수학의 부등식을 그대로 사용할 수 있다.\n  예를 들어 x &amp;gt; 0 and x &amp;lt; 20 과 0 &amp;lt; x &amp;lt; 20 은 같은 결과를 반환한다.\n\n\n# 코드 스타일 1\nx = 15\nif x &amp;gt; 0 and x &amp;lt; 20:\n\tprint(&#39;x는 0 이상 20 미만의 수입니다.&#39;)\n\n# 실행 결과 : x는 0 이상 20 미만의 수입니다.\n\n# 코드 스타일 2\nx = 15\nif 0 &amp;lt; x &amp;lt; 20:\n\tprint(&#39;x는 0 이상 20 미만의 수입니다.&#39;)\n\n# 실행 결과 : x는 0 이상 20 미만의 수입니다.\n\n\n반복문\n\n\n  특정한 소스코드를 반복적으로 실행하고자 할 때 사용하는 문법이다.\n  파이썬에서는 while문과 for문이 있는데, 어떤 것을 사용해도 상관 없다.\n    \n      다만 코딩 테스트에서의 실제 사용 예시를 확인해 보면, for문이 더 간결한 경우가 많다.\n    \n  \n\n\nwhile문\n\n1부터 9까지 모든 정수의 합 구하기 (while문)\n\ni = 1\nresult = 0\n\n# i가 9보다 작거나 같을 때 아래 코드를 반복적으로 실행\nwhile i &amp;lt;= 9:\n\tresult += i\n\ti += 1\n\nprint(result)\n\n# 실행 결과 : 45\n\n\n1부터 9까지 홀수의 합 구하기 (while문)\n\ni = 1\nresult = 0\n\n# i가 9보다 작거나 같을 때 아래 코드를 반복적으로 실행\nwhile i &amp;lt;= 9:\n\tif i % 2 == 1:\n\t\tresult += i\n\ti += 1\n\nprint(result)\n\n# 실행 결과 : 25\n\n\n반복문에서의 무한 루프\n\n\n  무한 루프(infinite Loop)란 끊임없이 반복되는 반복 구문을 의미\n    \n      코딩 테스트에서 무한 루프를 구현할 일은 거의 없으니 유의\n      반복문을 작성한 뒤에는 항상 반복문을 탈출할 수 있는지 확인 필요\n    \n  \n\n\nx = 10\n\nwhikle x &amp;gt; 5:\n\tprint(x)\n\n# 실행 결과 )\n# 10\n# 10\n# 10\n# 10\n# ...\n# Loop\n\n\nfor 문\n\n\n  반복문으로 for문을 이용할 수도 있다.\n  for문의 구조는 다음과 같은데, 특정한 변수를 이용하여 ‘in’ 뒤에 오는 데이터(리스트, 튜플 등)에 포함되어 있는 원소를 첫 번째 인덱스부터 차례대로 하나씩 방문한다.\n\n\n# for 변수 in 리스트:\n#\t 실행할 소스코드\n# \n\narray = [9, 8, 7, 6, 5]\n\nfor x in array:\n\tprint(x)\n\n# 실행 결과\n# 9\n# 8\n# 7\n# 6\n# 5\n\n\n\n  for문에서 연속적인 값을 차례대로 순회할 때는 range()를 주로 사용한다.\n    \n      이때 range(시작 값, 끝 값 + 1) 형태로 사용한다.\n      인자를 하나만 넣으면 자동으로 시작 값은 0이 된다.\n    \n  \n\n\nresult = 0\n\n# i는 1부터 9까지의 모든 값을 순회\nfor i in range(1, 10):\n\tresult += i\n\nprint(result)\n\n# 실행 결과 : 45\n\n\n파이썬의 continue 키워드\n\n\n  반복문에서 남은 코드의 실행을 건너뛰고, 다음 반복을 진행하고자 할 때 continue를 사용한다.\n  1부터 9까지의 홀수의 합을 구할 때 다음과 같이 작성할 수 있다.\n\n\nresult = 0\n\nfor i in range(1, 10):\n\tif i % 2 == 0:\n\t\tcontinue\n\tresult += i\n\nprint(result)\n\n# 실행 결괴 : 25\n\n\n파이썬의 break 키워드\n\n\n  반복문을 즉시 탈출하고자 할 때 break를 사용한다.\n  1부터 5까지의 정수를 차례대로 출력하고자 할 때 다음과 같이 작성할 수 있다.\n\n\ni = 1\n\nwhile True:\n\tprint(&quot;현재 i의 값 : &quot;, i)\n\tif i == 5:\n\t\tbreak\n\ti += 1\n\n# 실행 결과)\n# 현재 i의 값: 1\n# 현재 i의 값: 2\n# 현재 i의 값: 3\n# 현재 i의 값: 4\n# 현재 i의 값: 5\n\n\n학생들의 합격 여부 판단 예제 1) 점수가 80점만 넘으면 합격\n\nscores = [90, 85, 77, 65, 97]\n\nfor i in range(5):\n\tif scores[i] &amp;gt;= 80:\n\t\tprint(i + 1, &#39;번 학생은 합격입니다.&#39;)\n\n# 실행 결과)\n# 1 번 학생은 합격입니다.\n# 2 번 학생은 합격입니다.\n# 5 번 학생은 합격입니다.\n\n\n학생들의 합격 여부 판단 예제 2) 특정 번호의 학생은 제외하기\n\nscores = [90, 85, 77, 65, 97]\ncheating_student_list = {2, 4}\n\nfor i in range(5):\n    if i + 1 in cheating_student_list:\n        continue\n    if scores[i] &amp;gt;= 80:\n        print(i + 1, &quot;번 학생은 합격입니다.&quot;)\n\n# 실행 결과)\n#1 번 학생은 합격입니다.\n#5 번 학생은 합격입니다.\n\n\n중첩된 반복문(2중 for문): 구구단 예제\n\nfor i in range(2, 10):\n    for j in range(1, 10):\n        print(i, &quot;X&quot;, j, &quot;=&quot;, i*j)\n\n    print()\n\n# 실행 결과 )\n# 2 X 1 = 2\n# 2 X 2 = 4\n# 2 X 3 = 6\n# 2 X 4 = 8\n# 2 X 5 = 10\n# 2 X 6 = 12\n# 2 X 7 = 14\n# 2 X 8 = 16\n# 2 X 9 = 18\n\n# 3 X 1 = 3\n# 3 X 2 = 6\n# 3 X 3 = 9\n# 3 X 4 = 12\n# ....\n\n"
} ,
  
  {
    "title"    : "[Python] - 함수, 람다 표현식",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/10/Python-function-lambda.html",
    "date"     : "January 10, 2023",
    "excerpt"  : "함수\n\n\n  함수(Function)란 특정한 작업을 하나의 단위로 묶어 놓은 것을 의미한다.\n  함수를 사용하면 불필요한 소스코드의 반복을 줄일 수 있다.\n\n\n함수의 종류\n\n\n  내장 함수 : 파이썬이 기본적으로 제공하는 함수\n  사용자 정의 함수 : 개발자가 직접 정의하여 사용할 수 있는 함수\n\n\n함수 정의하기\n\n\n  프로그램에는 똑같은 코드가 반복적으로 사용되어야 할 때가 많다.\n  함수를 사용하면 소스코드의 길이를 줄일 수 있다.\n ...",
  "content"  : "함수\n\n\n  함수(Function)란 특정한 작업을 하나의 단위로 묶어 놓은 것을 의미한다.\n  함수를 사용하면 불필요한 소스코드의 반복을 줄일 수 있다.\n\n\n함수의 종류\n\n\n  내장 함수 : 파이썬이 기본적으로 제공하는 함수\n  사용자 정의 함수 : 개발자가 직접 정의하여 사용할 수 있는 함수\n\n\n함수 정의하기\n\n\n  프로그램에는 똑같은 코드가 반복적으로 사용되어야 할 때가 많다.\n  함수를 사용하면 소스코드의 길이를 줄일 수 있다.\n    \n      매개변수 : 함수 내부에서 사용할 변수\n      반환 값 : 함수에서 처리 된 결과를 반환\n    \n  \n\n\ndef 함수명(매개변수):\n\t실행할 소스코드\n\treturn 반환 값\n\n\n더하기 함수 예시 1)\n\ndef add(a, b):\n\treturn a + b\n\nprint(add(3, 7))\n\n# 실행 결과 : 10\n\n\n더하기 함수 예시 2)\n\ndef add(a, b):\n\tprint(&#39;함수의 결과:&#39;, a + b)\n\nadd(3, 7)\n\n#실행 결과 : 함수의 결과: 10\n\n\n파이썬 파라미터 직접 지정\n\n\n  파라미터의 변수를 직접 지정할 수 있다.\n    \n      이 경우 매개변수의 순서가 달라도 상관 없다.\n    \n  \n\n\ndef add(a, b):\n\tprint(&#39;함수의 결과:&#39;, a + b)\n\nadd(b = 3, a = 7)\n\n# 실행 결과 ) 함수의 결과: 10\n\n\nglobal 키워드\n\n\n  global 키워드로 변수를 지정하면 해당 함수에서는 지역 변수를 만들지 않고, 함수 바깥에 선언된 변수를 바로 참조하게 된다.\n\n\na = 0\n\ndef func():\n\tglobal a\n\ta += 1\n\nfor i in range(10):\n\tfunc()\n\nprint(a)\n\n# 실행 결과 : 10\n\n\n여러 개의 반환 값 (패킹: packing)\n\n\n  파이썬에서 함수는 여러 개의 반환 값을 가질 수 있다.\n\n\ndef operator(a, b):\n\tadd_var = a + b\n\tsubtract_var = a - b\n\tmultiply_var = a * b\n\tdivide_var = a / b\n\treturn add_var, subtract_var, multiply_var, divide_var # packing\n\na, b, c, d = operator(7, 3) # un packing\nprint(a, b, c, d)\n\n# 실행 결과 : 10 4 21 2.3333333333333335\n\n\n람다 표현식\n\n\n  람다 표현식을 이용하면 함수를 간단하게 작성할 수 있다.\n    \n      특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다는 점이 특징이다.\n    \n  \n\n\ndef add(a, b):\n\treturn a + b\n\n# 일반적인 add() 메서드 사용\nprint(add(3, 7))\n# 실행 결과 : 10\n\n# 람다 표현식으로 구현한 add() 메서드\nprint((lambda a, b: a + b)(3, 7))\n# 실행 결과 : 10\n\n\n람다 표현식 예시: 내장 함수에서 자주 사용되는 람다 함수\n\narray = [(&#39;홍길동&#39;, 50), (&#39;이순신&#39;, 32), (&#39;아무개&#39;, 74)]\n\ndef my_key(x):\n\treturn x[1]\n\nprint(sorted(array, key=my_key))\n# 실행 결과 : [(&#39;이순신&#39;, 32), (&#39;홍길동&#39;, 50), (&#39;아무개&#39;, 74)]\n\nprint(sorted(array, key=lambda x: x[1]))\n# 실행 결과 : [(&#39;이순신&#39;, 32), (&#39;홍길동&#39;, 50), (&#39;아무개&#39;, 74)]\n\n\n\n람다 표현식 예시: 여러 개의 리스트에 적용\n\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [6, 7, 8, 9, 10]\n\nresult = map(lambda a, b: a + b, list1, list2)\n\nprint(list(result))\n\n# 실행 결과 : [7, 9, 11, 13, 15]\n\n"
} ,
  
  {
    "title"    : "[Python] - 기본 입출력",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/10/Python-default-input-output.html",
    "date"     : "January 10, 2023",
    "excerpt"  : "기본 입출력\n\n\n  모든 프로그램은 적절한 (약속된) 입출력 양식을 가지고 있다.\n  프로그램 동작의 첫 번째 단계는 데이터를 입력 받거나 생성하는 것이다.\n  예시 ) 학생의 성적 데이터가 주어지고, 이를 내림차순으로 정렬한 결과를 출력하는 프로그램\n\n\n\n\n자주 사용되는 표준 입력 방법\n\n\n  input() 함수는 한 줄의 문자열을 입력 받는 함수이다.\n  map() 함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용한다.\n...",
  "content"  : "기본 입출력\n\n\n  모든 프로그램은 적절한 (약속된) 입출력 양식을 가지고 있다.\n  프로그램 동작의 첫 번째 단계는 데이터를 입력 받거나 생성하는 것이다.\n  예시 ) 학생의 성적 데이터가 주어지고, 이를 내림차순으로 정렬한 결과를 출력하는 프로그램\n\n\n\n\n자주 사용되는 표준 입력 방법\n\n\n  input() 함수는 한 줄의 문자열을 입력 받는 함수이다.\n  map() 함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용한다.\n  \n    예시) 공백을 기준으로 구분된 데이터를 입력 받을 때는 다음과 같이 사용한다.\n\n      list(map(int, input().split()))\n    \n  \n  \n    예시) 공백을 기준으로 구분된 데이터의 개수가 많지 않다면, 단순히 다음과 같이 사용한다.\n\n      a, b, c = map(int, input().split())\n    \n  \n\n\n입력을 위한 전형적인 소스코드 1)\n\n# 데이터의 개수 입력\nn = int(input())\n# 각 데이터를 공백을 기준으로 구분하여 입력\ndata = list(map(int, input().split()))\n\ndata.sort(reverse = True)\nprint(data)\n\n# 실행 결과 )\n# 5 - input\n# 65 90 75 34 99 - input\n# [99, 90, 75, 65, 34] - output\n\n\n\n입력을 위한 전형적인 소스코드 2)\n\n# n, m, k를 공백을 기준으로 구분하여 입력\nn, m, k = map(int, input().split())\n\nprint(n, m, k)\n\n# 실행 결과 )\n# 3 5 7 - input\n# 3 5 7 - output\n\n\n빠르게 입력 받기\n\n\n  사용자로부터 입력을 최대한 빠르게 받아야 하는 경우가 있다.\n  파이썬의 경우 sys 라이브러리에 정의되어 있는 sys.stdin.readline() 메서드를 이용한다.\n    \n      단, 입력 후 엔터(Enter)가 줄 바꿈 기호로 입력되므로 rstrip() 메서드를 함께 사용한다. ← Enter 기호 제거\n    \n  \n\n\nimport sys\n\n# 문자열 입력 받기\ndata = sys.stdin.readline().rstrip()\nprint(data)\n\n\n자주 사용되는 표준 출력 방법\n\n\n  파이썬에서 기본 출력은 print() 함수를 사용한다.\n    \n      각 변수를 콤마(,)를 이용하여 띄어쓰기로 구분하여 출력할 수 있다.\n    \n  \n  print()는 기본적으로 출력 이후에 줄 바꿈을 수행한다.\n    \n      줄 바꿈을 원치 않는 경우 ‘end’ 속성을 이용할 수 있다.\n    \n  \n\n\n# 출력할 변수들\na = 1\nb = 2\nprint(a, b)\n\nprint(7, end=&quot; &quot;)\nprint(8, end=&quot; &quot;)\n\n# 출력할 변수\nanswer = 7\nprint(&quot;정답은 &quot; + str(answer) + &quot;입니다.&quot;)\n\n# 실행 결과\n# 1 2\n# 7 8 정답은 7입니다.\n\n\nf-string\n\n\n  파이썬 3.6부터 사용 가능하며, 문자열 앞에 접두사 ‘f’를 붙여 사용한다.\n  중괄호 안에 변수명을 기입하여 간단히 문자열과 정수를 함께 넣을 수 있다.\n  f-string을 이용하면 정수형을 굳이 문자형으로 바꾸지 않고도 간단하게 코드 작성이 가능하다.\n\n\nanswer = 7\nprint(f&quot;정답은 {answer}입니다.&quot;)\n\n# 실행 결과 : 정답은 7입니다.\n\n"
} ,
  
  {
    "title"    : "[Python] - 집합 자료형, 사전 자료",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/09/Python-dictionary-data-type.html",
    "date"     : "January 9, 2023",
    "excerpt"  : "사전 자료형\n\n\n  사전 자료형은 키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다.\n    \n      앞서 다루었던 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비된다.\n    \n  \n  사전 자료형은 키와 값의 쌍을 데이터로 가지며, 원하는 ‘변경 불가능한 (Immutable) 자료형’을 키로 사용할 수 있다.\n  파이썬의 사전 자료형은 해시 테이블(Hash Table)을 이용하므로 데이터의 조회 및 수정에 있어서...",
  "content"  : "사전 자료형\n\n\n  사전 자료형은 키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다.\n    \n      앞서 다루었던 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비된다.\n    \n  \n  사전 자료형은 키와 값의 쌍을 데이터로 가지며, 원하는 ‘변경 불가능한 (Immutable) 자료형’을 키로 사용할 수 있다.\n  파이썬의 사전 자료형은 해시 테이블(Hash Table)을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.\n\n\n\n  \n    \n      키(Key)\n      값(Value)\n    \n  \n  \n    \n      사과\n      Apple\n    \n    \n      바나나\n      Banana\n    \n    \n      코코넛\n      Coconut\n    \n  \n\n\ndata = dict()\ndata[&#39;사과&#39;] = &#39;Apple&#39;\ndata[&#39;바나나&#39;] = &#39;Banana&#39;\ndata[&#39;코코넛&#39;] = &#39;Coconut&#39;\n\nprint(data)\n\nif &#39;사과&#39; in data:\n\tprint(&quot;&#39;사과&#39;를 키로 가지는 데이터가 존재합니다.&quot;)\n\n# 실행 결과 : &#39;사과&#39;를 키로 가지는 데이터가 존재합니다.\n\n\n\n  사전 자료형에서는 키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.\n    \n      키 데이터만 뽑아서 리스트로 이용할 때는 keys() 함수를 이용한다.\n      값 데이터만 뽑아서 리스트로 이용할 때는 values() 함수를 이용한다.\n    \n  \n\n\ndata = dict()\ndata[&#39;사과&#39;] = &#39;Apple&#39;\ndata[&#39;바나나&#39;] = &#39;Banana&#39;\ndata[&#39;코코넛&#39;] = &#39;Coconut&#39;\n\n# 키 데이터만 담은 리스트\nkey_list = data.keys()\n# 값 데이터만 담은 리스트\nvalue_list = data.values()\n\nprint(key_list)\n# 실행 결과 : dict_keys([&#39;사과&#39;, &#39;바나나&#39;, &#39;코코넛&#39;])\nprint(value_list)\n# 실행 결과 : dict_values([&#39;Apple&#39;, &#39;Banana&#39;, &#39;Coconut&#39;])\n\n# 각 키에 따른 값을 하나씩 출력\nfor key in key_list:\n\tprint(data[key])\n\n# 실행 결과 : \n# Apple\n# Banana\n# Coconut\n\n\n집합 자료형\n\n\n  집합은 다음과 같은 특징이 있다.\n    \n      중복을 허용하지 않는다.\n      순서가 없다.\n    \n  \n  집합은 리스트 혹은 문자열을 이용해서 초기화할 수 있다.\n    \n      이때 set() 함수를 이용한다.\n    \n  \n  혹은 중괄호 ({})안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있다.\n  데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.\n\n\n# 집합 자료형 초기화 방법 1\ndata = set([1, 1, 2, 3, 4, 4, 5])\nprint(data)\n# 실행 결과 : {1, 2, 3, 4, 5}\n\n# 집합 자료형 초기화 방법 2\ndata = {1, 1, 2, 3, 4, 4, 5}\nprint(data)\n# 실행 결과 : {1, 2, 3, 4, 5}\n\n\n\n  기본적인 집합 연산으로는 합집합, 교집합, 차집합 연산 등이 있다.\n    \n      합집합 : 집합 A에 속하거나 B에 속하는 원소로 이루어진 집함 ($A ∪ B$)\n      교집합 : 집합 A에도 속하고 B에도 속하는 원소로 이루어진 집합 ($A ∩ B$)\n      차집합 : 집합 A의 원소 중에도 B에 속하지 않는 원소들로 이루어진 집합($A - B$)\n    \n  \n\n\na = set([1, 2, 3, 4, 5])\nb = set([3, 4, 5, 6, 7])\n\n# 합집합\nprint(a | b)\n# 실행 결과 : {1, 2, 3, 4, 5, 6, 7}\n\n# 교집합\nprint(a &amp;amp; b)\n# 실행 결과 : {3, 4, 5}\n\n# 차집합\nprint(a - b)\n# 실행 결과 : {1, 2}\n\n\n집합 자료형 관련 함수\n\ndata = set([1, 2, 3])\nprint(data)\n# 실행 결과 : {1, 2, 3}\n\n# 새로운 원소 추가\ndata.add(4)\nprint(data)\n# 실행 결과 : {1, 2, 3, 4}\n\n# 새로운 원소 여러 개 추가\ndata.update([5, 6])\n# 실행 결과 : {1, 2, 3, 4, 5, 6}\n\n# 특정한 값을 갖는 원소 삭제\ndata.remove(3)\nprint(data)\n# 실행 결과 : {1, 2, 4, 5, 6}\n\n\n사전 자료형과 집합 자료형의 특징\n\n\n  리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.\n  사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 있다.\n    \n      사전의 키(Key) 혹은 집합의 원소(Element)를 이용해 O(1)의 시간 복잡도로 조회한다.\n    \n  \n\n"
} ,
  
  {
    "title"    : "[Python] - 언더바는 언제 사용하는가?",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/08/Python-under-bar.html",
    "date"     : "January 8, 2023",
    "excerpt"  : "Python에서 언더바 ( _ ) 는 어제 사용하는가?\n\n\n  파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바(_)를 자주 사용한다.\n  코드 1: 1부터 9까지의 자연수를 더하기\n    \n      1부터 9까지의 자연수를 매번 i라는 변수에 담기게 만들어야 하기 때문에 i 가 순회할 수 있도록 만들어주고, 그때마다 i의 값을 summary에 담아 출력하기 위해서 i를 for 문에서 사용\n    \n  \n\n\n...",
  "content"  : "Python에서 언더바 ( _ ) 는 어제 사용하는가?\n\n\n  파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바(_)를 자주 사용한다.\n  코드 1: 1부터 9까지의 자연수를 더하기\n    \n      1부터 9까지의 자연수를 매번 i라는 변수에 담기게 만들어야 하기 때문에 i 가 순회할 수 있도록 만들어주고, 그때마다 i의 값을 summary에 담아 출력하기 위해서 i를 for 문에서 사용\n    \n  \n\n\n# 1부터 9까지의 자연수를 더하기\nsummary = 0\nfor i in range(1, 10):\n\tsummary += i\nprint(summary)\n\n\n\n  코드 2: “Hello World” 를 5번 출력하기\n    \n      내부적으로 어떠한 변수 값이 사용되지 않고, 단순하게 어떠한 작업을 반복하고자 한다면 언더바(_) 처리를 해서 코드 1처럼 i와 같은 변수가 내부에서 사용되지 않는다는 점을 코드상으로 알려줄 수 있다.\n    \n  \n\n\n# &quot;Hello World&quot;를 5번 출력하기\nfor _ in range(5):\n\tprint(&quot;Hello World&quot;)\n\n"
} ,
  
  {
    "title"    : "[Python] - 리스트 자료형",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/syntax/2023/01/08/Python-data-type-list.html",
    "date"     : "January 8, 2023",
    "excerpt"  : "리스트 자료형\n\n\n  여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형이다.\n    \n      사용자 입장에서 C나 자바에서의 배열(Array)의 기능 및 연결 리스트와 유사한 기능을 지원한다.\n      C++의 STL vector와 기능적으로 유사하다.\n      리스트 대신에 배열 혹은 테이블이라고 부르기도 한다.\n    \n  \n\n\n리스트 초기화\n\n# 직접 데이터를 넣어 초기화\na = [1, 2, 3, 4, 5, 6...",
  "content"  : "리스트 자료형\n\n\n  여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형이다.\n    \n      사용자 입장에서 C나 자바에서의 배열(Array)의 기능 및 연결 리스트와 유사한 기능을 지원한다.\n      C++의 STL vector와 기능적으로 유사하다.\n      리스트 대신에 배열 혹은 테이블이라고 부르기도 한다.\n    \n  \n\n\n리스트 초기화\n\n# 직접 데이터를 넣어 초기화\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(a)\n\n# 실행 결과 : [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 네 번째 원소만 출력\nprint(a[3])\n\n# 실행 결과 : 4\n\n# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화\nn = 10\na = [0] * n\nprint(a)\n\n# 실행 결과 : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\n리스트의 인덱싱과 슬라이싱\n\n\n  인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱(Indexing)이라고 한다.\n    \n      파이썬의 인덱스 값은 양의 정수와 음의 정수를 모두 사용할 수 있다.\n      음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.\n    \n  \n\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 여덟 번째 원소만 출력\nprint(a[7])\n\n# 뒤에서 첫 번째 원소 출력\nprint(a[-1])\n\n# 뒤에서 세 번째 원소 출력\nprint(a[-3])\n\n# 네 번째 원소 값 변경\na[3] = 7\nprint(a)\n\n\n\n  리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱(Slicing)을 이용합니다.\n    \n      대괄호 안에 콜론(:)을 넣어서 시작 인데스와 끝 인덱스를 설정할 수 있습니다.\n      끝 인덱스는 실제 인덱스보다 1을 더 크게 설정합니다.\n    \n  \n\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 네 번째 원소만 출력\nprint(a[3])\n\n# 실행 결괴 : 4\n\n# 두 번째 원소부터 네 번째 원소까지\nprint(a[1 : 4])\n\n# 실행 결과 : [2, 3, 4]\n\n\n리스트 컴프리헨션\n\n\n  리스트를 초기화하는 방법 중 하나이다.\n    \n      대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다.\n    \n  \n\n\n# 0부터 9까지의 수를 포함하는 리스트\narray = [i for i in range(10)]\n# i 라는 변수가 0 ~ 9 까지 매번 증가를 하면서 반복을 할 때 마다,\n# i 의 값들을 원소로 설정해서 리스트를 만든다.\nprint(array)\n\n#실행 결과 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n  \n    리스트 컴프리헨션을 할 때는 반복문을 먼저 기입하는 것을 추천\n  \n  \n    리스트 컴프리헨션은 반복문 뿐만 아니라 내부적으로 조건문을 포함해서도 작성이 가능하다.\n  \n\n\n# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트\narray = [i for i in range(20) if i &amp;amp; 2 == 1]\n\nprint(array)\n# 실행 결과 : [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트\narray = [i * i for i range(1, 10)]\n\nprint(array)\n# 실행 결과 : [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\n리스트 컴프리헨션과 일반적인 코드 비교\n\n\n  실행 결과는 두 코드 모두 동일하다.\n  코드 1 : 리스트 컴프리헨션\n\n\n# 0 부터 19까지의 수 중에서 홀수만 포함하는 리스트\narray = [i for i in range(20) if i % 2 == 1]\n\nprint(array)\n\n# 실행 결과 : [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n\n\n  코드 2 : 일반적인 코드\n\n\n# 0 부터 19까지의 수 중에서 홀수만 포함하는 리스트\narray = []\nfor i in range(20):\n\tif i % 2 == 1:\n\t\tarray.append(i)\n\nprint(array)\n\n# 실행 결과 : [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n\n\n  리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용될 수 있다.\n  특히 N X M 크기의 2차원 리스트를 한 번에 초기화 해야 할 때 매우 유용하다.\n    \n      좋은 예시 : array = [ [0] * m for _ in range(n) ]\n    \n  \n\n\n# N X M 크기의 2차원 리스트 초기화\nn = 4\nm = 3\narray = [[0] * m for _ in range(n)]\nprint(array)\n\n# 실행 결과 : [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n\n\n  만약 2차원 리스트를 초기화할 때 다음과 같이 작성하면 예기치 않은 결과가 나올 수 있다.\n    \n      잘못된 예시 : array = [[0] * m] * n\n      위 코드는 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다.\n      파이썬은 기본적으로 리스트 자료형을 이용해서 어떠한 변수 값을 할당하게 되면 내부적으로 해당 리스트느 객체 형태로 처리하게 된다. 별도의 주소 값을 가지게 된다. 그렇기 때문에 잘못된 예시의 코드처럼 어떠한 리스트 객체 값을 n번 곱하게 되면, 단순하게 그 내부적인 길이가 m인 리스트를 n번 만큼 해당 참조 값을 복사하는 것과 같기 때문에 해당 방식을 의도하지 않았다면 잘못된 예시라고 할 수 있다.\n    \n  \n\n\n# N X M 크기의 2차원 리스트 초기화 (잘못된 방법)\nn = 4\nm = 3\narray = [[0] * m] * n\nprint(array)\n\n# 실행 결과 [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\narray[1][1] = 5\nprint(array)\n# 해당 2차원 리스트는 같은 주소 번지를 참조하고 있기 때문에 밑에 실행 결과처럼 출력 된다.\n# 실행 결과 [[0, 5, 0], [0, 5, 0], [0, 5, 0], [0, 5, 0]]\n\n\n리스트 관련 기타 메서드\n\n\n  \n    \n      함수명\n      사용법\n      설명\n      시간 복잡도\n    \n  \n  \n    \n      append()\n      변수명.append()\n      리스트에 원소를 하나 삽입할 때 사용한다.\n      O(1)\n    \n    \n      sort()\n      변수명.sort()\n      기본 정렬 기능으로 오름차순으로 정렬한다.\n      O(NlogN)\n    \n    \n       \n      변수명.sort(reverse = True)\n      내림차순으로 정렬한다.\n      O(NlogN)\n    \n    \n      reverse()\n      변수명.reverse()\n      리스트의 원소의 순서를 모두 뒤집어 놓는다.\n      O(N)\n    \n    \n      insert()\n      insert(삽입할 위치 인덱스, 삽입할 값)\n      특정한 인덱스 위치에 원소를 삽입할 때 사용한다.\n      O(N)\n    \n    \n      count()\n      변수명.count(특정 값)\n      리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다.\n      O(N)\n    \n    \n      remove()\n      변수명.remove(특정 값)\n      특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 하나만 제거한다.\n      O(N)\n    \n  \n\n\na = [1, 4, 3]\nprint(&quot;기본 리스트 : &quot;, a)\n# 실행 결과 : 기본 리스트 :  [1, 4, 3]\n\n# 리스트에 원소 삽입\na.append(2)\nprint(&quot;삽입 : &quot;, a)\n# 실행 결과 : 삽입 :  [1, 4, 3, 2]\n\n# 오름차순 정렬\na.sort()\nprint(&quot;오름차순 정렬 : &quot;, a)\n# 실행 결과 : 오름차순 정렬 :  [1, 2, 3, 4]\n\n# 내림차순 정렬\na.sort(reverse = True)\nprint(&quot;내림차순 정 렬 : &quot;, a)\n# 실행 결과 : 내림차순 정렬 :  [4, 3, 2, 1]\n\n\na = [4, 3, 2, 1]\n\n# 리스트 원소 뒤집기\na.reverse()\nprint(&quot;원소 뒤집기 : &quot;, a)\n# 실행 결과 : 원소 뒤집기 :  [1, 2, 3, 4]\n\n# 특정 인덱스에 데이터 추가\na.insert(2, 3)\nprint(&quot;인덱스 2에 3 추가 : &quot;, a)\n# 실행 결과 : 인덱스 2에 3추가 :  [1, 2, 3, 3, 4]\n\n# 특정 값인 데이터 개수 세기\nprint(&quot;값이 3인 데이터 개수 : &quot;, a.count(3))\n# 실행 결과 : 값이 3인 데이터 개수 2\n\n# 특정 값 데이터 삭제\na.remove(1)\nprint(&quot;값이 1인 데이터 삭제 : &quot;, a)\n# 실행 결과 : 값이 1인 데이터 삭제 :  [2, 3, 3, 4]\n\n\n리스트에서 특정 값을 가지는 원소를 모두 제거하기\n\n\n  집합 자료형을 사용하면 특정한 원소의 존재 유무를 체크할 때 용이\n\n\na = [1, 2, 3, 4, 5, 5, 5]\nremove_set = {3, 5} # 집합 자료형\n\n# remove_list에 포함되지 않는 값만 저장\nresult = [i for i in a if i not in remove_set]\nprint(result)\n\n# 실행 결과 : [1, 2, 4]\n\n"
} ,
  
  {
    "title"    : "Typescript를 사용하는 이유",
    "category" : "",
    "tags"     : " Typescript, Javascript",
    "url"      : "/syntax/2022/12/31/Typescript.html",
    "date"     : "December 31, 2022",
    "excerpt"  : "개요\n\n\n  TypeScript는 JavaScript를 기반으로 만들어진 언어이다.\n  JavaScript가 가지고 있는 여러 문제를 해결하고 보완하기 위해 만들어짐\n  TypeScript를 사용하면 타입의 안정성에 있어서 Java나 C#과 비슷한 개발 경험을 제공한다.\n  JavaScript 개발자가 버그나 코드의 안정성 그리고 생산성을 높이고 싶다면 배우기 좋은 언어이다.\n    \n      JS의 문제점 (TypeScript를 사용하...",
  "content"  : "개요\n\n\n  TypeScript는 JavaScript를 기반으로 만들어진 언어이다.\n  JavaScript가 가지고 있는 여러 문제를 해결하고 보완하기 위해 만들어짐\n  TypeScript를 사용하면 타입의 안정성에 있어서 Java나 C#과 비슷한 개발 경험을 제공한다.\n  JavaScript 개발자가 버그나 코드의 안정성 그리고 생산성을 높이고 싶다면 배우기 좋은 언어이다.\n    \n      JS의 문제점 (TypeScript를 사용하는 이유)\n        \n          가장 큰 이유로는 자바스크립트가 매우 유연한 언어임이 크다.\n          \n            해당 코드로 예를 들어보자\n\n            let javaScriptResult = [1, 2, 3, 4] + false\n/*\n  위 코드는 숫자가 담겨있는 배열에 \nBoolean Type의 false를 더하려고 하는 코드이다.\n*/\n      \nconsole.log(&#39;JS Result &#39;, javaScriptResult)\n// JS Result &#39;1,2,3,4false&#39;\n      \n/*\n  그리고 해당 코드의 결과로는 console.log 의 결과처럼 출력이 된다.\n      \n  [문제점]\n  1. 첫 번째 문제로는 배열이 사라진다. \n  결과 값이 그냥 String Type이 되어버린다.\n  2. 두 번째 문제로는 Boolean Type의 false는\n  String이 되어버린다. \n  3. 세 번째 문제로는 결론적으로 JS는 위의 코드를 그대로 허용해버린다.\n  다른 언어에서는 위와 같은 코드를 허용하지 않고 에러를 띄워주는데,\n  JS는 이런 말도 안되는 코드를 허용해서 결과를 만들어 버리는 문제에 있다.\n      \n  즉, Data Type에 대한 강제가 없다.\n  이런 코드를 쓰는 개발자는 없겠지만 이걸 그대로 \n  결과 값으로 치는 것에 문제가 있다.\n*/\n            \n\n            //이번에는 divide라는 function을 만들어보겠다.\nfunction divide(a, b){\n  return a / b\n}\n      \n/*\n  위와 같은 함수를 이상적으로 사용하는 방법은 당연하게도\n  숫자 타입의 데이터를 a와 b에 넣어주는 것이다.\n  즉 입력 값이 숫자일 때만 해당 함수가 실행이 되어야 한다는 것이다.\n        \n  하지만 자바스크립트는 이 함수를 올바르게 사용하도록 강제하지 않는다.\n*/\n      \n//올바른 함수 사용\nlet result1 = divide(2, 3);\nconsole.log(&#39;result1&#39;, result1);\n// result1 0.6666666666666666\n      \n//잘못된 함수 사용\nlet result2 = divide(&quot;xxxxxx&quot;);\nconsole.log(&#39;result2 &#39;, result2);\n// result2 NaN\n// 숫자 타입의 인자를 받아야 하는데 문자열을 입력 받고도 에러가 나지 않고,\n// Not a Number를 출력한다.\n// 그리고 입력 값이 두 개인데 하나만 보내도 이걸 실행해준다.\n            \n          \n          위 코드 예제를 보면 JavaScript는 divide 함수에서 a와 b가 Number Type이어야 하는지, 그리고 함수의 필수 입력 값이 두 개인지 아니면 선택사항인지를 전혀 고려하지 않는다.\n          \n            가장 심각한 Error는 바로 런타임 에러이다.\n\n            const objectVar = { name: &#39;seobisback&#39; }\n      \nobjectVar.email()\n/*\n  위와 같은 에러는 그나마 감사하게도 TypeError 메세지를 띄우고,\n  이런 함수는 없다라고 에러를 띄워줄 것이다.\n      \n  하지만 문제는 이런 코드는 컴파일 자체가 되면 안되는데,\n  실행이 되고 난 후 유저가 해당 코드가 포함된 기능을 사용할 때\n  에러가 발생한다는 것이다.\n      \n  다른 언어같으면 이런 식으로 코드를 작성하면 실행조차 되지 않고\n  컴파일을 시도하는 순간에 막힐 것이다.\n*/\n            \n          \n          위와 같은 문제 때문에 JS 개발자가 TypeScript로 넘어가는 것이다.\n        \n      \n    \n  \n  TypeScript를 사용하면 VS Code IDE가 좋은 개발 경험을 준다고 한다. (노마드 코더 강의 중) 이유로는 TS와 VS Code는 Microsoft에서 만들었고, 편한 자동완성을 지원하며 위 코드처럼 런타임 에러가 발생할 수 있는 코드에는 해당 코드를 실행하면 유저에게 런타임 에러가 일어난다고 경고도 해준다고 한다.\n\n\nTypeScript가 도움을 주는 방식\n\nTypeScript로 작성한 코드를 컴파일하면, 자바스크립트 코드가 된다.\n\n여기서 생기는 의문으로는 ‘타입스크립트 코드가 결국 자바스크립트 코드가 되면 어떻게 에러를 핸들링 해준다는 건데?’ 이다.\n\n\n  TypeScript는 에러가 있으면 JavaScript 코드로 컴파일 되지 않는다.\n  TypeScript는 에러가 발생할 것 같은 코드를 감지하면, 아예 JavaScript로 컴파일 되지 않는다. 이런 기능은 유저가 코드를 실행하는 런타임에 발생하는 것이 아니기 때문에 만약 TypeScript가 성공적으로 컴파일 되어서 JavaScript 코드를 주면 TypeScript 코드가 제대로 작성이 된 것이고, Data의 Type에도 문제가 없다는 뜻이 된다. 즉 유저가 실행하는 JavaScript 코드에는 해당 에러가 존재하지 않는다는 의미가 된다.\n  TypeScript에는 두 가지의 접근 방식이 있다.\n    \n      Java처럼 데이터와 변수의 타입을 명시적으로 정의할 수 있고,\n      JavaScript처럼 변수만 생성하고 타입을 명시하지 않을 수도 있다.\n        \n          위와 같이 타입을 명시하지 않을 경우 TypeScript가 해당 변수의 타입을 추론해준다는 것이다.\n          \n            Type Checker 가 Type을 확인하는 방식\n\n            // 타입을 명시하지 않는 방식\nlet a = &#39;Hello&#39;;\n/*\n  이렇게 코드를 작성하는 것만으로 Typescript는 a의 타입을 추론해준다.\n  a에 담긴 데이터를 보고는 a는 string type 이어야 한다 라는 것을\n  Typescript가 추론하는 것이다.\n*/\n      \n// 타입을 명시하는 방식\nlet b : boolean = false;\n/*\n  이렇게 코드를 작성하면 Typescript는 b의 타입을 추론할 필요 없이\n  개발자가 해당 변수의 타입을 명시하고 생성하였기 때문에 다른 타입으로\n  변수의 값을 수정하려고 할 경우 에러를 발생시켜준다.\n*/\n            \n          \n        \n      \n    \n  \n  많은 타입을 재사용할 수 있게 만들 경우 Alias 타입을 생성하면 된다.\n\n\n// Alias(별칭) 타입을 생성한 경우\n/*\n\tAlias 타입을 생성할 경우\n\n\t타입 명은 대문자로 시작한다. - Pascal case\n*/ \ntype Player = {\n\tname: string,\n\tage? : number // 선택적 입력 가능\n}\n\nconst playerOne : Player = {\n\tname: &#39;PlayerOne&#39;\n}\n\nconst playerTwo : Player = {\n\tname: &#39;PlayerTwo&#39;,\n\tage: 20\n}\n\n// Alias(별칭) 타입을 생성하지 않고 타입을 명시할 경우\nconst playerThree : {\n\tname: string,\n\tage? : number\n} = {\n\tname: &#39;PlayerThree&#39;\n}\n\n\n\n  함수가 return 하는 값의 타입을 설정하는 방법\n\n\ntype Player = {\n\tname: string,\n\tage?: number\n}\n\nfunction playerMaker(name: string) : Player {\n\treturn {\n\t\tname\n\t}\n}\n\n// Arrow Function을 사용할 경우\nconst playerMaker = (name: string) : Player =&amp;gt; \n\nconst playerOne = playerMaker(&#39;PlayerOne&#39;);\n\nplayerOne.age = 20;\n\n\nReadOnly\n\nTypeScript에는 readonly를 설정하는 기능이 있다.\n\n말 그대로 readonly 설정된 변수 등에 write 기능을 허용하지 않는 것이다.\n\nreadonly가 설정된 것은 immutability(불변성)을 갖게 된다.\n\n// use reedonly\nconst numbers: readonly number[] = [1,2,3,4];\n\nnumbers.push(1) //Error \n\n// can write\nconst numbers: number[] = [1,2,3,4];\n\nnumbers.push(1) // work\n\n\nTuple\n\nTuple은 Array를 생성할 수 있게 하는데 있어서 최소한의 길이를 가져야 하고,\n\n특정 위치에 특정 타입이 존재해야 한다.\n\nconst player: [string, number, boolean] = [&#39;seobisback&#39;, 1, true];\n\nplayer[0] = 1 // Error \n\n\nany\n\nTypescript 에서는 여러가지 타입이 존재하는데 그것은 Javascript 타입이 많다\n\n하지만 Typescript에서만 사용할 수 있는 타입이 있고 그것은 ‘any’ 이다.\n\nany는 Typescript의 보호장치에서 벗어날 수 있게 해준다.\n\n가장 좋은 것은 any를 사용하지 않는 것이다. (당연하게도 Typescript의 보호 장치를 사용하고 바보같은 실수를 하지 않기 위해서 Typescript를 사용하기 때문)\n\n하지만 Typescript에는 ‘any’가 존재하고 그렇기 때문에 공부할 필요는 있다.\n\n‘any’를 사용하면 말 그대로 모든 타입을 허용하는 것이다.\n\n코드를 보자\n\n// if use &#39;any&#39;\nconst a : any[] = [1,2,3,4]\nconst b : any = true\n\na + b // 원래라면 에러를 던져야 하는 Typescript지만 이 코드를 허용해버린다.\n\n// 현재 코드에서 &#39;any&#39;를 지우면 Typescript는 바로 에러를 던진다.\n\n\nunknown\n\nTypescript에만 존재하는 타입이다.\n\n만약 API에게 응답 데이터를 받는데 해당 데이터의 타입을 알 수 없을 경우\n\n‘unknown’이라는 타입을 사용한다.\n\nlet a: unknown;\n\nlet b = a + 1; //Error\n\n// typescript에서 unknown을 사용하려면 type을 check해야한다.\n\nif(typeof a === &#39;number&#39;){\n\tlet b = a + 1; // 허용\n}\n// 위와 같이 타입을 체크 후 사용할 경우 typescript는 이를 허용한다.\n// 왜냐하면 해당 범위 안에서의 a는 number이기 때문이다.\n\nlet b = a.toUpperCase() // Error\n\nif(typeof a === &#39;string&#39;){\n\tlet b = a.toUpperCase() // 허용\n}\n// 위와 같이 타입을 체크 후 사용할 경우 typescript는 이를 허용한다.\n// 왜냐하면 해당 범위 안에서의 a는 stringr이기 때문이다.\n\n\n위와 같이 변수의 타입을 미리 알 수 없을 경우 ‘unknown’을 사용한다.\n\nvoid\n\nTypescript에만 존재하는 타입이다.\n\nvoid는 아무것도 return하지 않는 함수를 대상으로 사용한다.\n\n보통은 void를 따로 지정해줄 필요가 없다.\n\n/*region Same Code*/\nfunction hello(){\n\tconsole.log(&#39;say hello&#39;);\n}\n\nfunction hello(): void{\n\tconsole.log(&#39;say hello&#39;);\n}\n/*endregion Same Code*/\n\nconst a = hello();\na.toUpperCase(); // Error\n\n\nnever\n\nTypescript에만 존재하는 타입이다.\n\n‘never’ 는 함수가 절대 return하지 않을 때 발생한다.\n\n예를 들자면 함수에서 exception(예외)이 발생할 때 등이 있다.\n\n// 에러가 발생하는 함수\nfunction hello():never{\n\tconsole.log(&#39;x&#39;)\n}\n\n// 정상적으로 동작하는 함수\nfunction hello():never{\n\tthrow new Error(&#39;xxx&#39;);\n}\n// 이 함수는 return 하지 않고 오류를 발생시키는 함수이다.\n// 위와 같은 상황일 때, never를 사용한다.\n\nfunction hello(name: string|number){\n\tif(typeof name === &#39;string&#39;){\n\t\tname // (parameter) name: string\n\t} else if(typeof name === &#39;number&#39;){\n\t\tname // (parameter) name: number\n\t} else {\n\t\t// 이 코드는 절대 실행되지 않아야 한다라는 뜻\n\t\tname // (parameter) name: never\n\t}\n}\n\n"
} ,
  
  {
    "title"    : "ReactHook_useRef",
    "category" : "",
    "tags"     : " React, Hooks, useRef",
    "url"      : "/syntax/2022/12/27/React-useRef.html",
    "date"     : "December 27, 2022",
    "excerpt"  : "useRef 는 언제 사용이 되는가?\n\n\n  useRef를 사용하는 대표적인 두 가지 상황\n  ref는 state와 비슷하게 어떠한 값을 저장해두는 저장공간으로 사용한다.\n  State\n    \n      함수형 컴포넌트는 결국 함수이기 때문에 state 변경에 의한 리렌더링은 함수를 다시 호출하는 것을 의미한다. 고로 state가 변경되면 아래와 같은 절차를 따르게 된다.\n      절차 : State의 변화 → 렌더링 → 컴포넌트 내부...",
  "content"  : "useRef 는 언제 사용이 되는가?\n\n\n  useRef를 사용하는 대표적인 두 가지 상황\n  ref는 state와 비슷하게 어떠한 값을 저장해두는 저장공간으로 사용한다.\n  State\n    \n      함수형 컴포넌트는 결국 함수이기 때문에 state 변경에 의한 리렌더링은 함수를 다시 호출하는 것을 의미한다. 고로 state가 변경되면 아래와 같은 절차를 따르게 된다.\n      절차 : State의 변화 → 렌더링 → 컴포넌트 내부 변수들 초기화\n      이 현상 때문에 함수 내부의 변수들이 다시 초기화 되는 경우가 발생하여 개발자가 원하지 않는 순간에 함수가 리렌더링 되는 현상에 곤란해지는 경우가 있다.\n    \n  \n  Ref\n    \n      Ref의 유용한 점은 개발자가 Ref 안에 있는 값을 아무리 변경해도 Component는 다시 렌더링 되지 않는다는 장점이 있다.\n      변경 시 렌더링을 발생시키지 말아야 하는 값을 다룰 때 가장 편리하다.\n      Ref의 변화 → No 렌더링 → 변수들의 값이 유지됨\n      또한 Component가 아무리 리렌더링 되어도 Ref 안에 값은 변하지 않고 유지가 된다.\n    \n  \n  State의 변화 → 렌더링 → 하지만 Ref의 값은 유지됨.\n  Ref를 통해 DOM 요소에 접근할 수 있다.\n    \n      Ref를 사용하면 DOM 요소에 접근하여 focus() 같은 DOM 요소에 사용하는 메서드를 사용할 수 있다.\n      Vanilla JS의 document.querySelector()와 비슷하다.\n    \n  \n\n\nconst ref = useRef(value);\n\nconsole.log(ref) // { current : value }\n\n//ref Object는 value 값을 수정이 가능하다\nref.current = &quot;hello&quot;\nconsole.log(ref) // { current : &quot;hello&quot; }\n\nref.current = &quot;nice&quot;\nconsole.log(ref) // { current : &quot;nice&quot; }\n\n\n\n  반환된 ‘ref’ 는 Component의 전생애주기를 통해 유지되기 때문에 Component가 리렌더링 되어도 언마운트 되기 전까지는 해당 값이 유지가 된다.\n\n\nRef를 이용한 데이터 저장 및 컴포넌트 렌더링 관리\n\nimport React, { useState, useRef } from &#39;react&#39;;\n\nconst App = () =&amp;gt; {\n\tconst [count, setCount] = useState(0);\n\tconst countRef = useRef(0);\n\n\tconsole.log(&#39;Rerendering now!!&#39;)\n\n\tconst increaseCountState = () =&amp;gt; {\n\t\tsetCount(count + 1);\n\t}\n\n\tconst increaseCountRef = () =&amp;gt; {\n\t\tcountRef.current = countRef.current + 1;\n\t}\n\n\treturn (\n\t\t&amp;lt;div&amp;gt;\n\t\t\t&amp;lt;p&amp;gt;State: {count}&amp;lt;/p&amp;gt;\n\t\t\t&amp;lt;p&amp;gt;Ref: {countRef.current}&amp;lt;/p&amp;gt;\n\t\t\t&amp;lt;button onClick={increaseCountState}&amp;gt;State Plus&amp;lt;/button&amp;gt;\n\t\t\t&amp;lt;button onClick={increaseCountRef}&amp;gt;Ref Plus&amp;lt;/button&amp;gt;\n\t\t&amp;lt;/div&amp;gt;\n\t);\n}\n\nexport default App;\n\n\nRef를 이용한 DOM 접근\n"
} ,
  
  {
    "title"    : "ReactHook_useMemo",
    "category" : "",
    "tags"     : " React, Hooks, useMemo",
    "url"      : "/syntax/2022/12/27/React-useMemo.html",
    "date"     : "December 27, 2022",
    "excerpt"  : "useMemo\n\n\n  Memo 는 Memoization(메모이제이션)을 뜻한다.\n    \n      Memoization - 동일한 값을 return 하는 함수를 반복적으로 호출해야 된다면, 해당 값을 메모리에 저장해서 필요할 때 마다 메모리에서 꺼내서 재사용을 하는 기법이다 (메모리에 캐싱)\n      쉽게 말하면 자주 필요한 값을 맨 처음 계산할 때 캐싱을 해두고, 다시 계산 하는 것이 아니라 캐시에서 꺼내쓰는 방법\n      Reac...",
  "content"  : "useMemo\n\n\n  Memo 는 Memoization(메모이제이션)을 뜻한다.\n    \n      Memoization - 동일한 값을 return 하는 함수를 반복적으로 호출해야 된다면, 해당 값을 메모리에 저장해서 필요할 때 마다 메모리에서 꺼내서 재사용을 하는 기법이다 (메모리에 캐싱)\n      쉽게 말하면 자주 필요한 값을 맨 처음 계산할 때 캐싱을 해두고, 다시 계산 하는 것이 아니라 캐시에서 꺼내쓰는 방법\n      React에서 함수형 컴포넌트는 함수이기 때문에 state 나 props의 변화로 인해 자동으로 렌더링 될 때 항상 재 실행된다. 그 때마다 무거운 로직을 가졌지만 변경이 되지 않을 계산 값을 맨 처음에만 계산하여 useMemo로 ‘메모이제이션’ 해두고 필요한 곳에 캐싱해둔 값을 재사용하여 해당 컴포넌트가 렌더링 되어도 무거운 로직은 다시 사용하지 않은 채 렌더링하여 컴포넌트의 성능을 최적화 시킬 수 있는 것이다.\n    \n  \n  useMemo 는 꼭 필요한 곳에서만 사용해야한다.\n    \n      useMemo를 남용하면 오히려 성능에 무리가 될 수 있다.\n      useMemo를 사용한다는 것은 값을 재활용해서 사용하기 위해 따로 메모리를 사용하여 저장을 해놓는 것이기 때문에 불필요한 값들까지 모두 Memoization 해버리면 오히려 성능이 악화 될 수 있다.\n    \n  \n\n\n/*\n\n - useMemo는 2개의 인자를 받는다.\n\n첫 번째는 callback 함수 - Memoization 해줄 값을 계산해서 return 하는 용도,\n\tcallback 함수가 return 하는 값이 useMemo가 return 하는 값이다.\n\n두 번째는 배열 - &#39;의존성 배열(Dependency array)&#39; 이라고도 불린다.\n\t배열에 담긴 요소에 값이 update될 때만 callback 함수를 다시 호출해서 Memoization 된 값을 update 후\n\t다시 Memoization 해준다.\n\t만약 빈 배열을 그대로 넘겨줄 경우 Component가 Mount 되었을 때만 검사하고, 이 후에는 update하지 않는다.\n\n*/\nconst value = useMemo(()=&amp;gt;{\n\treturn calculate();\n}, [item])\n\n\nExample 1\n\nimport React, { useMemo, useState } from &#39;react&#39;;\n\nconst hardCalculate = (number) =&amp;gt; {\n\tfor (let i = 0; i &amp;lt; 999999999; i++){} //계산에 딜레이를 주기 위한 의미 없는 for 문\n\treturn number + 10000;\n}\n\nconst easyCalculate = (number) =&amp;gt; {\n\treturn number + 1;\n}\n\nfunction App(){\n\tconst [hardNumber, setHardNumber] = useState(1);\n\tconst [easyNumber, setEasyNumber] = useState(1);\n\n\t//const hardSum = hardCalculate(hardNumber);\n\t/*\n\t\tDependency Array에 hardNumber를 추가하여,\n\t\thardNumber가 변경될 때만, useMemo가 callback 함수에서 hardCalculate 실행시켜서 재연산한다.\n\t\t만약에 hardNumber가 변경되지 않았다면 기존에 hardSum에 가지고 있던 값을 재사용하게 된다.\n\t*/\n\tconst hardSum = useMemo(() =&amp;gt; {\n\t\treturn hardCalculate(hardNumber);\n\t}, [hardNumber])\n\tconst easySum = easyCalculate(easyNumber);\n\n\treturn (\n\t\t&amp;lt;div&amp;gt;\n\t\t\t&amp;lt;p&amp;gt;Hard Calculater&amp;lt;/p&amp;gt;\n\t\t\t&amp;lt;input\n\t\t\t\ttype=&quot;number&quot;\n\t\t\t\tvalue={hardNumber}\n\t\t\t\tonChange={(event) =&amp;gt; setHardNumber(parseInt(event.target.value))} \n\t\t\t/&amp;gt;\n\t\t\t&amp;lt;span&amp;gt; + 10000 = {hardSum}&amp;lt;/span&amp;gt;\n\n\t\t\t&amp;lt;br /&amp;gt;\n\n\t\t\t&amp;lt;p&amp;gt;Easy Calculater&amp;lt;/p&amp;gt;\n\t\t\t\t&amp;lt;input\n\t\t\t\t\ttype=&quot;number&quot;\n\t\t\t\t\tvalue={hardNumber}\n\t\t\t\t\tonChange={(event) =&amp;gt; easyCalculate(parseInt(event.target.value))} \n\t\t\t\t/&amp;gt;\n\t\t\t\t&amp;lt;span&amp;gt; + 1 = {easySum}&amp;lt;/span&amp;gt;\n\t\t\t&amp;lt;/div&amp;gt;\n\t);\n}\n\nexport default App;\n\n\nExample 2\n"
} ,
  
  {
    "title"    : "ReactHook_useContext + Context API",
    "category" : "",
    "tags"     : " React, Hooks, Context",
    "url"      : "/syntax/2022/12/27/React-useContext-ContextAPI.html",
    "date"     : "December 27, 2022",
    "excerpt"  : "useContext + Context API\n\nContext API : Context 는 APP 안에서 전역적으로 사용되는 data를 여러 Component 끼리 공유할 수 있는 방법을 제공한다.\n\nContext를 사용하면 상위 Component가 일일이 하위 Component에게 전달하지 않아도 된다.\n\nprops를 통해 하위 Component에 계속해서 전달하는 일련의 과정을 Prop Drilling 이라고도 한다.\n\nuseContex...",
  "content"  : "useContext + Context API\n\nContext API : Context 는 APP 안에서 전역적으로 사용되는 data를 여러 Component 끼리 공유할 수 있는 방법을 제공한다.\n\nContext를 사용하면 상위 Component가 일일이 하위 Component에게 전달하지 않아도 된다.\n\nprops를 통해 하위 Component에 계속해서 전달하는 일련의 과정을 Prop Drilling 이라고도 한다.\n\nuseContext : useContext는 Context로 공유한 data를 쉽게 받아올 수 있게 도와주는 역할을 한다.\n\n\n\n«그림 1. Context와 useContext»\n\nContext 는 필요할 때만 사용해야함\n\nContext의 주된 목적은 다양한 Level에 있는 많은 Component들에게 전역적인 데이터를 전하기 위함이다.\n\n\n  Context를 사용하면 Component를 재사용하기 어려워 질 수 있다.\n  (React 공식문서 내용중)Prop drilling을 피하기위한 목적이라면 Component Composition(컴포넌트 합성)이 더 간단한 해결책일 수도 있다고 제안하고 있다.\n\n\nExample 1\n\npath : context/ThemeContext.js\n\nimport { createContext } from &quot;react&quot;;\n\nexport const ThemeContext = createContext(null);\n\n\npath : App.js\n\nimport { useState } from &#39;react&#39;;\nimport &#39;./App.css&#39;;\nimport Page from &#39;./components/Page&#39;;\nimport { ThemeContext } from &#39;./context/ThemeContext&#39;;\n\nfunction App(){\n\tconst [isDark, setIsDark] = useState(false);\n\n\treturn (\n\t\t&amp;lt;ThemeContext.Provider value=&amp;gt;\n\t\t\t&amp;lt;Page isDark={isDark} setIsDark={setIsDark} /&amp;gt;\n\t\t&amp;lt;/ThemeContext.Provider&amp;gt;\n\t);\n}\n\nexport default App;\n\n\npath: component/Page.js\n\nimport React, {useContext} from &#39;react&#39;;\nimport Content from &#39;./Content&#39;;\nimport Footer from &#39;./Footer&#39;;\nimport Header from &#39;./Header&#39;;\n\nfunction Page(){\n\treturn (\n\t\t&amp;lt;div&amp;gt;\n\t\t\t&amp;lt;Header /&amp;gt;\n\t\t\t&amp;lt;Content /&amp;gt;\n\t\t\t&amp;lt;Footer /&amp;gt;\n\t\t&amp;lt;/div&amp;gt;\n\t);\n}\n\nexport default Page;\n\n\npath: component/Header.js\n"
} ,
  
  {
    "title"    : "Javascript Types",
    "category" : "",
    "tags"     : " JavaScript",
    "url"      : "/syntax/2022/12/27/Javascript-type.html",
    "date"     : "December 27, 2022",
    "excerpt"  : "원시 (Primitive) 타입\n\n\n  String\n  Number\n  Boolean\n  Null\n  Undefined\n  Biglnt\n  Symbol\n\n\n객체 (Object) 타입 - 원시 타입을 제외한 모든 것\n\n\n  Object\n  Array\n\n\n\n\n—&amp;gt; 원시 타입 : 어떠한 변수에 원시 타입의 값을 할당하면 그 값은 변수에 바로 할당된다.\n\n—&amp;gt; 객체 타입 : 어떠한 변수에 객체 타입의 값을 할당하면 크기가 크기 때문에 ...",
  "content"  : "원시 (Primitive) 타입\n\n\n  String\n  Number\n  Boolean\n  Null\n  Undefined\n  Biglnt\n  Symbol\n\n\n객체 (Object) 타입 - 원시 타입을 제외한 모든 것\n\n\n  Object\n  Array\n\n\n\n\n—&amp;gt; 원시 타입 : 어떠한 변수에 원시 타입의 값을 할당하면 그 값은 변수에 바로 할당된다.\n\n—&amp;gt; 객체 타입 : 어떠한 변수에 객체 타입의 값을 할당하면 크기가 크기 때문에 바로 변수에 할당되는 것이 아닌 메모리 상에 공간이 할당되어서 그 메모리 안에 보관된다. 그 후 그 변수에는 객체가 담긴 주소 값이 할당된다.\n\n\n\n—&amp;gt; 원시 타입 : 같은 원시 값을 갖고 있는 변수를 비교 연산자로 비교할 경우 true로 동일하게 판단한다. (변수 안에 있는 값이 동일하기 때문)\n\n—&amp;gt; 객체 타입 : 같은 값을 갖고 있는 두 객체를 비교 연산자로 비교할 경우 false를 반환한다. ( 변수는 객체의 주소 값을 갖고 있고 두 객체는 다른 주소 값에 저장되어 있어 주소 값이 동일하지 않기 때문)\n"
} ,
  
  {
    "title"    : "상태 관리 라이브러리 Redux VS MobX",
    "category" : "",
    "tags"     : " React, StateManagement, Redux, MobX",
    "url"      : "/syntax/2022/12/26/React-Redux.html",
    "date"     : "December 26, 2022",
    "excerpt"  : "회사에서 React로 프로젝트를 진행하게 되어, 상태관리 라이브러리에 관해서 조사를 하게 되었다.\n개인적으로 토이 프로젝트를 진행하며 Redux를 사용하여 state를 관리하였고,\nReact 생태계에서 Redux 사용량이 현재도 압도적이기 때문에 Redux를 사용하는게 가장 안전하지 않을까 라고 생각하였지만 회사 선배가 MobX도 현재 많은 기업에서 사용중이고, 조사를 해보니 MobX가 Redux와는 또 다른 매력이 있기 때문에 좀 더 조...",
  "content"  : "회사에서 React로 프로젝트를 진행하게 되어, 상태관리 라이브러리에 관해서 조사를 하게 되었다.\n개인적으로 토이 프로젝트를 진행하며 Redux를 사용하여 state를 관리하였고,\nReact 생태계에서 Redux 사용량이 현재도 압도적이기 때문에 Redux를 사용하는게 가장 안전하지 않을까 라고 생각하였지만 회사 선배가 MobX도 현재 많은 기업에서 사용중이고, 조사를 해보니 MobX가 Redux와는 또 다른 매력이 있기 때문에 좀 더 조사를 진행해보았고, 나와 같은 고민을 하는 분이 계실거라 생각하여 그 고민에 도움을 드리면 좋겠다라고 생각이 들어 정리해둔 글을 포스팅 해봅니다.\n\nRedux VS Mobx\n\n상태관리 라이브러리\n\n\n  Redux\n\n\n\n\n일단 기억해야 하는 존재는 컴포넌트, 더해주라는 Action, Reducer, 그리고 Store 정도다. 위 그림의 흐름을 정리해보자.\n\n\n  컴포넌트에서 전역 Store에 관리되고 있는 상태 num 에 1을 더하고자 한다.\n  컴포넌트에서 상태에 직접 접근할 수 없고, Store에서 제공하는 방법을 사용해야 한다. 여기서 Reducer를 이용한다. Reducer는 어떤 Action을 원하는지 확인하고 그에 따라 상태를 업데이트해주는 함수다.\n  이 Reducer에 Action으로 { type: ‘ADD’ } 를 보내주면 num 에 1을 더해주는걸로 미리 약속을 해둔 상태다.\n  컴포넌트는 Reducer에 Action { type: ‘ADD’ }를 발송(dispatch)한다.\n  Reducer는 이 요청을 받고 내부에 있는 상태, num 에다가 1을 더해준다. 즉, 상태를 업데이트한다.\n  상태가 업데이트된 후 이를 참조하고 있는 컴포넌트들에게 num 이 업데이트되었으니 리랜더링을 해야 한다고 알린다.\n\n\n이 구조가 저기 위에서 얘기했던 데이터의 흐름을 한 방향으로, 한 지점을 지나도록 하는 전역 상태 관리 라이브러리의 구조라고 생각할 수 있다.\n\n일단 데이터 변경부터 리랜더링까지 한 방향으로 진행이 되고 있다. 또한, 상태에 직접 접근해 변경하는 것은 불가능하므로, 반드시 Store의 Reducer를 거쳐야 한다. 공통적으로 한 지점을 지나가도록 만들어졌고, 업데이트 로직도 분리되어있음을 알 수 있다.\n\n\n  Mobx - 글로벌 상태 관리 툴\n    \n      장점\n        \n          OOP(객체지향적)코드를 작성할 수 있다.\n        \n      \n    \n  \n\n\nRedux와 Mobx의 차이점\n\n\n  Redux는 상태를 변경하기 위해 reducer, action 등 코드를 작성해주어야 하고, 프로젝트의 규모가 커짐에 따라 이러한 코드들이 꼬이고 복잡해져 점점 스파게티 코드가 되어간다.\n  Redux는 함수형 프로그래밍에 영향을 받은 라이브러리이다. MobX는 OOP권장하는 라이브러리이다. OOP에 익숙한 개발자들이 쉽게 접근하고 사용할 수 있다.\n  Redux는 Store의 상태를 Immutable(불변)하게 변경하기 때문에 항상 새로운 상태를 반환해주어야함 (Read Only), MobX는 Mutable(변경)하게 변경이 가능함\n  \n    Redux는 구조상 Store와 Component의 연결을 위해 번잡한 코드들을 계속 작성하여야 한다.(reducer, store) MobX는 이러한 코드를 데코레이터를 사용하여 깔끔하게 작성할 수 있다.\n  \n  React MobX tutorial 및 이해\n\n\n\n\n\n  FileName : MovieStore.js\n\n\nimport {action, makeObservable, observable} from &#39;mobx&#39;;\n/*\naction(Function-함수) : action 안에서 observable 값을 변경할 때 사용함\nmakeObservable(Function-함수) : makeObservable 안에서 변수를 observable로 변경해 줄 수 있다.\nobservable(Variable-변수) : observable이 된 변수가 변경이되면, \n자동으로 이 observable을 보고 있는 Component들이 observable을 따라서 반응 후 Refresh 된다.\n*/\n\nclass Movie {\n\tid;\n\ttitle;\n\trate;\n\n\tconstructor(id, title, rate){\n\t\tthis.id = id;\n\t\tthis.title = title;\n\t\tthis.rate = rate;\n\t}\n}\n\nexport class MovieStore{ // Movie의 repository 역할\n\trootStore;\n\t/*\n\t\t해당 스토어외에 다른 스토어가 있을 경우 rootStore로 관리해주면 편하기 때문에\n\t\t미리 선언해둠\n\t*/\n\n\tmovies = []; // makeObservable 함수 안에서 observable로 변경된 &#39;movies&#39; 변수는 변경되면\n\t//MovieStore를 listening 중인 모든 component가 변경이 된다.\n\t// 만약 Typescript를 사용중이며 decorature 지원을 활성화 하였으면 makeObservable을 사용하는 것이 아닌\n\t//\n\t// @observable\n\t// movies = [];\n\t// 형태로 간소화하여 사용할 수 있다.\n\n\tconstructor(root){\n\t\tmakeObservable(this, {\n\t\t\t//해당 class(MovieStore)를 listening 중인 모든 component가 변경되게 할 수 있다.\n\t\t\tmovies: observable, // movies가 observable 변수로 변경이된다.\n\t})\t\t\n\n\t\tthis.rootStore = root;\n\n\t\tthis.movies = [\n\t\t\tnew Movie(1, &quot;LOTR&quot;, 5),\n\t\t\tnew Movie(2, &quot;Harry Potter&quot;, 4),\n\t\t\tnew Movie(3, &quot;창궐&quot;, 0)\n\t\t]\n\t}\n}\n\n\n\n  FileName : RootStore.js\n\n\nimport {MovieStore} from &quot;./MovieStore&quot;;\n\n// RootStore에서 가지고 있는 모든 Store들을 Access 가능하게 한다.\n// 만약 Store를 하나 더 만들려면 class 내부에 넣고, constructor 안에 선언하여 주면 된다.\nexport class RootStore{\n\tmovieStore;\n\n\tconstructor(){\n\t\tthis.movieStore = new MovieSotre(this);\n\n\t}\n}\n\n\n\n  FileName : Context.js\n\n\n1. MobX 의 주요 개념들에 대해서 살펴보자.\n\n1) Observable State\n\n\n  관찰 받고 있는 상태라는 뜻인데, 개발을 하다보면 상태는 항상 변할 수 있기 때문에 이 상태가 바뀐다면 MobX에서는 이를 캐치해낼 수 있습니다. 원시값들(string, number, boolean등등), 객체, 배열안에 객체 던 어떤 값들이 바뀌던지 MobX는 상태의 변화를 캐치할 수 있습니다.\n\n\n2) Computed Value\n\n\n  연산된 값이라는 뜻인데, 주로 성능 최적화를 위해서 많이 사용하긴 합니다. 연산에 기반 되는 값(상태값)이 변화할때만 새로 연산하고 바뀌지 않는다면 그냥 기존 값을 사용할 수 있도록 해줍니다.\n\n\n3) Reactions\n\n\n  값이 바뀔때에 따라 해야 할 일을 정의하는 것 , 예를들어 1)의 Observable State가 바뀌었을때 이 리액션을 통해 어떤 로직을 실행시키는 것이죠.\n\n\n4) Actions\n\n\n  상태에 변화를 일으키는 것, 1)의 Observable State를 변화 시키는 코드를 호출하면 액션\n\n"
} ,
  
  {
    "title"    : "React Navigation",
    "category" : "",
    "tags"     : " React, ReactNative",
    "url"      : "/syntax/2022/12/26/React-Navigation.html",
    "date"     : "December 26, 2022",
    "excerpt"  : "이 포스팅은 회사에서 React Native를 사용한 프로젝트를 진행하며, \nReact Navigation에 관해 조사한 내용을 정리한 글이다.\n\nReact Navigation\n\n\n\n\n  모바일 애플리케이션은 보통 여러 화면으로 구성되어 있다. 이러한 애플리케이션을 만들려면 내비게이션 관련 서드 파티 라이브러리를 사용해야 함.\n  대표적인 내비게이션에 괸련하여 사용할 수 있는 라이브러리\n    \n      react-navigation\n ...",
  "content"  : "이 포스팅은 회사에서 React Native를 사용한 프로젝트를 진행하며, \nReact Navigation에 관해 조사한 내용을 정리한 글이다.\n\nReact Navigation\n\n\n\n\n  모바일 애플리케이션은 보통 여러 화면으로 구성되어 있다. 이러한 애플리케이션을 만들려면 내비게이션 관련 서드 파티 라이브러리를 사용해야 함.\n  대표적인 내비게이션에 괸련하여 사용할 수 있는 라이브러리\n    \n      react-navigation\n        \n          리엑트 네이티브 커뮤니티에서 관리, 리엑트 공식 메뉴얼에서도 이 라이브러리로 화면을 전환하는 방법을 소개할 정도로 사용률이 가장 높은 라이브러리.\n          Navigation 기능이 자바스크립트로 구현되어 있음.\n        \n      \n      react-native-navigation\n        \n          홈페이지 제작 서비스 Wix에서 관리\n          이 라이브러리는 이미 만들어진 네이티브 앱에 리엑트 네이티브를 적용하는 경우 사용하기에 더 적합하며, 내비게이션 기능이 자바스크립트가 아닌 각 플랫폼의 네이티브 코드로 구현되어 있기 때문에 react-navigation보다 더욱 네이티브스러운 사용 경험을 제공한다.\n        \n      \n    \n  \n\n\nUse\n\n\n  리엑트 네이티브 프로젝트에 라이브러리를 적용하기 위해서는 @react-navigation/native에서 NavigationContainer 컴포넌트를 불러와 앱 전체를 감싸주어야 한다.\n\n\nimport React from &#39;react&#39;;\nimport {NavigationContainer} from &#39;@react-navigation/native&#39;;\nimport {createNativeStackNavigator} from &#39;@react-navigation/native-stack&#39;;\nimport HomeScreen from &#39;../component/navigation/HomeScreen&#39;;\nimport DetailScreen from &#39;../component/navigation/DetailScreen&#39;;\n\nconst Navigation = () =&amp;gt; {\n\tconst Stack = createNativeStackNavigator();\n\n\treturn (\n\t\t&amp;lt;NavigationContainer&amp;gt;\n\t\t\t&amp;lt;Stack.Navigator initialRouteName=&quot;Home&quot;&amp;gt;\n\t\t\t\t&amp;lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&amp;gt;\n\t\t\t\t&amp;lt;Stack.Screen name=&quot;Detail&quot; component={DetailScreen} /&amp;gt;\n\t\t\t&amp;lt;/Stack.Navigator&amp;gt;\n\t\t&amp;lt;/NavigationContainer&amp;gt;\n\t);\n}\n\n\nconst Stack = createNativeStackNavigator();\n\n\n\n  createNativeStackNavigator 함수를 사용해 네이티브 스택 네비게이터를 Stack이라는 객체에 할당한다.\n  이 안에는 Stack.Navigator 라는 컴포넌트와 Stack.Screen 컴포넌트가 들어있다.\n\n\n&amp;lt;NavigationContainer&amp;gt;\n  &amp;lt;Stack.Navigator initialRouteName=&quot;Home&quot;&amp;gt;\n    ...\n  &amp;lt;/Stack.Navigator&amp;gt;\n&amp;lt;/NavigationContainer&amp;gt;\n\n\n\n  Stack.Navigator는 NavigationContainer 사이에 넣어야 정상적으로 동작하고, initialRouteName 이라는 속성은 기본적으로 보여줄 화면의 이름을 설정한다. initialRouteName을 설정하지 않으면 첫 번째 Stack.Screen이 보여진다.\n\n\n&amp;lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&amp;gt;\n&amp;lt;Stack.Screen name=&quot;Detail&quot; component={DetailScreen} /&amp;gt;\n\n\n\n  Stack.Screen을 사용해 각 화면을 설정하는데 name 속성은 화면의 이름을 설정한 것이고, 이 값은 다른 화면으로 이동하거나 현재 화면이 어떤 화면인지 조회할 때 사용한다. name속성은 대문자로 표기하는 것을 권장한다.\n\n\nHomeScreen Component\n\nimport React from &#39;react&#39;;\nimport { View, Button } from &#39;react-native&#39;;\n\nfunction HomeScreen({navigator}){\n\treturn (\n\t\t&amp;lt;View&amp;gt;\n\t\t\t&amp;lt;Button \n\t\t\t\ttitle=&quot;Detail 열기&quot;\n\t\t\t\tonPress={ () =&amp;gt; navigation.navigate(&#39;Detail&#39;)}\n\t\t\t\t// onPress={ () =&amp;gt; navigation.push(&#39;Detail&#39;)}\n\t\t\t/&amp;gt;\n\t\t&amp;lt;/View&amp;gt;\n\t);\n}\n\n\n\n  스크린으로 사용된 컴포넌트는 navigation이라는 객체를 받아올 수 있는데, 이 객체에 navigate 함수 또는 push 함수를 사용해 화면을 이동한다.\n\n\nDetailScreen Component\n\nimport React from &#39;react&#39;;\nimport {View, Text} from &#39;react-native&#39;;\n\nfunction DetailScreen(){\n\treturn (\n\t\t&amp;lt;View&amp;gt;\n\t\t\t&amp;lt;Text&amp;gt;Detail&amp;lt;/Text&amp;gt;\n\t\t&amp;lt;/View&amp;gt;\n\t);\n}\n\n\nReact Navigation 프로젝트 스크린 구조 참고 velog\n\n\n  \n    \n      [[React native] VIVA\n      navigator구조, Screen 구성](https://velog.io/@inryu/React-native-VIVA-navigator%EA%B5%AC%EC%A1%B0-Screen-%EA%B5%AC%EC%84%B1)\n    \n  \n\n\n출처 : https://velog.io/@inryu/React-native-VIVA-navigator구조-Screen-구성\n\nReact Navigation 종속성 에러 관련\n"
} 
  
  ,
  
  {
  
  "title"    : "프리온보딩 프론트엔드 챌린지 1월 - CRUD w React Query’",
  "category" : "",
  "tags"     : " OnBoarding, React, ReactQuery, Typescript",
  "url"      : "/portfolio/preonboarding",
  "date"     : "January 1, 2023",
  "excerpt"  : "\n\n\n  Wanted 프리온보딩 프론트엔드 챌린지 1월 Thumbnail Image\n\n\n개요\n\n\n  \n    출처 - https://www.wanted.co.kr/events/pre_challenge_fe_5\n\n    \n  \n  \n    Wanted - 프리온보딩 프론트엔드 챌린지 1월\n    \n      \n        12.22 (목) - 1.5 (목) (진행중)\n\n        참가 신청 및 사전 미션 수행 (사전미션 섹션 링크 참조...",
  "content"  : "\n\n\n  Wanted 프리온보딩 프론트엔드 챌린지 1월 Thumbnail Image\n\n\n개요\n\n\n  \n    출처 - https://www.wanted.co.kr/events/pre_challenge_fe_5\n\n    \n  \n  \n    Wanted - 프리온보딩 프론트엔드 챌린지 1월\n    \n      \n        12.22 (목) - 1.5 (목) (진행중)\n\n        참가 신청 및 사전 미션 수행 (사전미션 섹션 링크 참조)\n      \n      \n        1.9 (월) - 1.20 (금)\n\n        기술 역량 향상 (2주) - 강의 : 화요일 &amp;amp; 금요일, 저녁 8시 (총 12시간, 온라인)\n      \n      \n        1.23 (월) - 2.19 (일)\n\n        취업 챌린지 진행 (4주) - 이력서 지원부터 ~ 합격까지 (개별 취업 활동)\n      \n      \n        2.20 (월) - 3월 중\n\n        챌린지 종료 및 시상\n      \n    \n  \n\n\n\n\n사전 과제\n\n\n  기간 12.22 (목) - 1.5 (목) (진행중)\n  \n    과제 명세 Link\n\n    https://github.com/starkoora/wanted-pre-onboarding-challenge-fe-1-api\n  \n  진행중인 과제 Git Repo\n    \n      Client - https://github.com/sdf5771/wanted-pre-onboarding-challenge-fe-1.git\n      API SERVER - https://github.com/sdf5771/wanted-pre-onboarding-challenge-fe-1-api.git\n    \n  \n\n\n\n\n명세 본문 내용\n\n:: 원티드 프리온보딩 챌린지 프론트엔드 코스 사전과제 안내 &amp;amp; API\n\n1-1) 사전과제 진행 가이드\n\n\n  제공해드리는 API Repository를 활용하여 가이드에 따라 Todo App을 작성, 본인의 github에 Public으로 올려주세요. (주의: Public이 아닐 경우 과제를 확인할 수 없습니다)\n  완성한 과제는 모집 마감 후 설문 조사를 통해 제출해주세요. (개강 시 설문 조사 링크 전달 예정)\n  제출 레파지토리 명은 wanted-pre-onboarding-challenge-fe-1로 생성해 주세요.\n  과제 수행 개수에 따라 기본적인 평가가 이루어지며, 커리큘럼 운영 과정에서 최소한의 수준을 파악하기 위한 용도입니다.\n  코드의 일관성, 가독성, 함수 분리, 컴포넌트 설계, 코드 퀄리티 등을 기준으로 세부적인 평가가 이루어집니다.\n  해당 과제에 대한 해설은 개강 후 진행될 예정입니다.\n  README.md를 꼭 작성해 주세요. 본인에 대한 소개나 프로젝트 소개 등 자유롭게 작성해주시면 됩니다.\n  반드시 함수 컴포넌트로 개발해주세요. (React Hooks)\n\n\n* 문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.\n\n1-2) 클라이언트 구현 과제 안내\n\nAssignment 1 - Login / SignUp\n\n\n  /auth 경로에 로그인 / 회원가입 기능을 개발합니다\n    \n      로그인, 회원가입을 별도의 경로로 분리해도 무방합니다\n      최소한 이메일, 비밀번호 input, 제출 button을 갖도록 구성해주세요\n    \n  \n  이메일과 비밀번호의 유효성을 확인합니다\n    \n      이메일 조건 : 최소 @, . 포함\n      비밀번호 조건 : 8자 이상 입력\n      이메일과 비밀번호가 모두 입력되어 있고, 조건을 만족해야 제출 버튼이 활성화 되도록 해주세요\n    \n  \n  로그인 API를 호출하고, 올바른 응답을 받았을 때 루트 경로로 이동시켜주세요\n    \n      응답으로 받은 토큰은 로컬 스토리지에 저장해주세요\n      다음 번에 로그인 시 토큰이 존재한다면 루트 경로로 리다이렉트 시켜주세요\n      어떤 경우든 토큰이 유효하지 않다면 사용자에게 알리고 로그인 페이지로 리다이렉트 시켜주세요\n    \n  \n\n\nAssignment 2 - Todo List\n\n\n  Todo List API를 호출하여 Todo List CRUD 기능을 구현해주세요\n    \n      목록 / 상세 영역으로 나누어 구현해주세요\n      Todo 목록을 볼 수 있습니다.\n      Todo 추가 버튼을 클릭하면 할 일이 추가 됩니다.\n      Todo 수정 버튼을 클릭하면 수정 모드를 활성화하고, 수정 내용을 제출하거나 취소할 수 있습니다.\n      Todo 삭제 버튼을 클릭하면 해당 Todo를 삭제할 수 있습니다.\n    \n  \n  한 화면 내에서 Todo List와 개별 Todo의 상세를 확인할 수 있도록 해주세요.\n    \n      새로고침을 했을 때 현재 상태가 유지되어야 합니다.\n      개별 Todo를 조회 순서에 따라 페이지 뒤로가기를 통하여 조회할 수 있도록 해주세요.\n    \n  \n  한 페이지 내에서 새로고침 없이 데이터가 정합성을 갖추도록 구현해주세요\n    \n      수정되는 Todo의 내용이 목록에서도 실시간으로 반영되어야 합니다\n    \n  \n\n\n과제 참고 사항\n\n\n  로컬 서버를 실행했을 때 생성되는 db/db.json이 DB 역할을 하게 됩니다. 해당 파일을 삭제하면 DB는 초기화 됩니다.\n  로그인 / 회원 가입 기능은 유저를 DB에 추가하고 JWT 토큰을 응답으로 돌려줄 뿐, 실제 유저별로 Todo 목록을 관계 지어 관리하지는 않습니다. (모든 유저가 하나의 Todo를 가짐)\n  로그아웃은 클라이언트 단에서 localStorage에 저장된 token을 삭제하는 방식으로 간단히 구현해주세요.\n\n\n2-1) API 실행\n\n&amp;gt; yarn\n\n&amp;gt; yarn start # &amp;lt;http://localhost:8080&amp;gt;\n\n\n\n2-2) API 스펙\n\nTodos\n\n\n  getTodos\n  getTodoById\n  createTodo\n  updateTodo\n  deleteTodo\n\n\nAuth\n\n\n  login\n  signUp\n\n\n1-3) Todos\n\ngetTodos\n\nURL\n\n\n  GET /todos\n  Headers\n    \n      Authorization: login token\n    \n  \n\n\n응답 예시\n\n{\n  &quot;data&quot;: [\n    {\n      &quot;title&quot;: &quot;hi&quot;,\n      &quot;content&quot;: &quot;hello&quot;,\n      &quot;id&quot;: &quot;z3FGrcRL55qDCFnP4KRtn&quot;,\n      &quot;createdAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;,\n      &quot;updatedAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;\n    },\n    {\n      &quot;title&quot;: &quot;hi&quot;,\n      &quot;content&quot;: &quot;hello&quot;,\n      &quot;id&quot;: &quot;z3FGrcRL55qDCFnP4KRtn&quot;,\n      &quot;createdAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;,\n      &quot;updatedAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;\n    }\n  ]\n}\n\n\n\ngetTodoById\n\nURL\n\n\n  GET /todos/:id\n  Headers\n    \n      Authorization: login token\n    \n  \n\n\n응답 예시\n\n{\n  &quot;data&quot;: {\n    &quot;title&quot;: &quot;hi&quot;,\n    &quot;content&quot;: &quot;hello&quot;,\n    &quot;id&quot;: &quot;z3FGrcRL55qDCFnP4KRtn&quot;,\n    &quot;createdAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;,\n    &quot;updatedAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;\n  }\n}\n\n\n\ncreateTodo\n\nURL\n\n\n  POST /todos\n  Parameter\n    \n      title: string\n      content: string\n    \n  \n  Headers\n    \n      Authorization: login token\n    \n  \n\n\n응답 예시\n\n{\n  &quot;data&quot;: {\n    &quot;title&quot;: &quot;hi&quot;,\n    &quot;content&quot;: &quot;hello&quot;,\n    &quot;id&quot;: &quot;z3FGrcRL55qDCFnP4KRtn&quot;,\n    &quot;createdAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;,\n    &quot;updatedAt&quot;: &quot;2022-07-24T14:15:55.537Z&quot;\n  }\n}\n\n\n\nupdateTodo\n\nURL\n\n\n  PUT /todos/:id\n  Parameter\n    \n      title: string\n      content: string\n    \n  \n  Headers\n    \n      Authorization: login token\n    \n  \n\n\n응답 예시\n\n{\n  &quot;data&quot;: {\n    &quot;title&quot;: &quot;제목 변경&quot;,\n    &quot;content&quot;: &quot;내용 변경&quot;,\n    &quot;id&quot;: &quot;RMfi3XyOKoI5zd0A_bsPL&quot;,\n    &quot;createdAt&quot;: &quot;2022-07-24T14:25:48.627Z&quot;,\n    &quot;updatedAt&quot;: &quot;2022-07-24T14:25:48.627Z&quot;\n  }\n}\n\n\n\ndeleteTodo\n\nURL\n\n\n  DELETE /todos/:id\n  Headers\n    \n      Authorization: login token\n    \n  \n\n\n응답 예시\n\n{\n  &quot;data&quot;: null\n}\n\n\n\n1-4) Auth\n\nlogin\n\nURL\n\n\n  POST /users/login\n  Parameter\n    \n      email: string\n      password: string\n    \n  \n\n\n응답 예시\n\n{\n  &quot;message&quot;: &quot;성공적으로 로그인 했습니다&quot;,\n  &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiJ9.YXNkZkBhc2RmYXNkZi5jb20.h-oLZnV0pCeNKa_AM3ilQzerD2Uj7bKUn1xDft5DzOk&quot;\n}\n\n\n\nsignUp\n\nURL\n\n\n  POST /users/create\n  Parameter\n    \n      email: string\n      password: string\n    \n  \n\n\n응답 예시\n\n{\n  &quot;message&quot;: &quot;계정이 성공적으로 생성되었습니다&quot;,\n  &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiJ9.YXNkZkBhc2RmYXNkZi5jb20.h-oLZnV0pCeNKa_AM3ilQzerD2Uj7bKUn1xDft5DzOk&quot;\n}\n\n\n\n\n\nClient SIde 구현 (사전과제) (완료)\n\n/auth\n\n\n  Login - 작업 완료\n  SignUp - 작업 완료\n\n\nhttps://youtu.be/GjzYHI-4sx8\n\n\n  LocalStorage\n\n\n\n\n/todos - main page\n\n\n\ngetTodos - 작업완료 - 모든 todo 정보를 서버에 Request 후 렌더링\n\n\n  headers - token\n\n\ncreateTodo - 작업 완료 - 서버에 해당하는 todo를 만드는 POST 요청 후 Request Data 기존 State에 병합 후 리렌더링\n\n\n  \n    TodoApp.tsx 코드 중\n\n    \n  \n\n\ngetTodoById - 작업완료 - 해당하는 할 일을 클릭할 시 상세보기 View\n\nupdateTodo - 작업완료 - 해당하는 할 일의 내용 변경\n\ndeleteTodo - 작업완료 - 해당하는 할 일 삭제\n\nhttps://youtu.be/Ahr69YCvS_s\n\n사전 과제 (제출 완료)\n\n\n\n\n\n2023.01.10일자 교육 후일담\n\n[Code refactoring] - 원티드 프리온보딩 프론트엔드 챌린지 - 사전과제\n\n원티드에서 프리온보딩 프론트엔드 챌린지를 참여하고 있다.\n\n라이브 세션에 참가하신 개발자 분들이 500명이 넘어서 설마 내 코드가 리뷰되겠어? 라는 생각이 있었는데\n\n사전 과제로 제출한 코드 중 유저의 토큰을 관리하는 코드에 관해 멘토님이 리뷰를 진행해주셨다.\n\n멘토님이 리뷰 주신 코드\n\n\n  path : modules/auth/authValidation.tsx\n\n\nexport const getUserInfomation = async () =&amp;gt; {\n    let getUserInfoResult = {\n        success: false,\n        email: &#39;&#39;,\n        token: &#39;&#39;,\n    }\n    let emailResult = await localStorage.getItem(&#39;email&#39;);\n    let tokenResult = await localStorage.getItem(&#39;token&#39;);\n\n    if(emailResult &amp;amp;&amp;amp; tokenResult){\n        getUserInfoResult.email = emailResult;\n        getUserInfoResult.token = tokenResult;\n        getUserInfoResult.success = true;\n    }\n\n    return getUserInfoResult;\n}\n\n\n\n  부끄럽게도 벌써 실수가 눈에 보인다\n얼마전까지 React Native를 공부하면서 ‘Async Storage’를 공부했는데\nlocalStorage에 비동기 작업을 걸려고 await를 사용하는 아주 기초적인 실수를 해버린 것;;🫠\n구현하고 제출하느라 정신 없어서 눈치를 못채고 제출했더니 이런 실수를 그대로 제출했다니..\n\n\n저걸 라이브 세션에서 보고는 어질 어질했다..\n\n하지만 실수를 했으면 고쳐야 하는 것\n\n멘토님이 주신 해당 코드의 피드백)\n\n  get- 접두사 → 동사인가?\n  localStorage는 비동기일까? → 함수의 색(color) 문제 (https://willowryu.github.io/2021-05-21/)\n\n\n그리고 해당 소스를 더 가독성 좋게 리팩토링 하는 것을 직접 보여주셨다.\n\n리팩토링\n\n\n  해당 소스에서 크게 문제가 되는 점은 멘토님이 피드백 주신 두 가지\n    \n      localStorage는 비동기인가?\n      \n        해당 모듈의 네이밍이 적절한가?\n\n        \n          우선 localStorage의 모든 작업은 동기적으로 이루어진다.\n그렇기 때문에 비동기로 사용하려던 내용을 수정하고 해당 부분의 코드가 수정이 필요하다.\n\n          해당 모듈의 네이밍이 적절한가?\n항상 함수나 변수 이름 작명은 많은 고민을 낳는 것 같다..\n우선 ’get’ 을 떠올릴 때 무엇인가를 얻어온다 라는 느낌까지는 괜찮은데\n지금 다시 보니까 API를 호출할거 같은 느낌이 든다.\n\n          그리고 멘토님의 리팩토링 과정을 보고 좀 더 간결하게 코드를 작성할 수 있을 것 같다.\n\n        \n      \n    \n  \n  정리가 된 코드\n\n\nexport const getUserInfomation = () =&amp;gt; {\n\t\tconst email = localStorage.getItem(&#39;email&#39;);\n\t\tconst token = localStorage.getItem(&#39;token&#39;);\n\n\t\tconst conditions = [email, token]\n\n\t\tif(conditions.every(condition =&amp;gt; !!condition)) {\n\t\t\treturn {\n        success: true,\n        email,\n        token,\n\t    }\n\t\t}\n\n    return {\n        success: false,\n        email: &#39;&#39;,\n        token: &#39;&#39;,\n    }\n}\n\n\n\n  비동기 사용을 위한 async await 를 코드에서 덜어내고,\n\n  localStorage에서 해당 값의 정보를 가져오는 부분을 모듈 상단 부로 이동\n\n  array에 localStorage에서 받아온 결과를 넣고,\n\n  token과 email 값의 검사를 Array.prototype.every() 를 통해 테스트한다.\nBoolean 값을 반환하기 때문에 if 문을 통해 해당 모듈에서 반환을 해주기 위한 \n결과 값들을 바로 반환하여 줄 수 있다.\n\n  구현 후 리팩토링에도 정말 많은 신경을 쓰도록 노력해봐야겠다.\n\n\n"
  
} ,
  
  {
  
  "title"    : "Qualk - ‘맞춤 지식 정보 제공 플랫폼’",
  "category" : "",
  "tags"     : " React, Typescript, Redux, React Query",
  "url"      : "/portfolio/qualk",
  "date"     : "January 1, 2023",
  "excerpt"  : "\n\n\n  ‘Qualk’ 현재 메인 페이지\n\n\n\nLink : https://qualk.co.kr/\n\nQualk\n\nGithub : https://github.com/sdf5771/tree/main/qualk-front\n\nqualk/qualk-front at main · sdf5771/qualk\n\n프로젝트 개요\n\n\n  기획, 설계, 런칭을 목적으로 만든 각 분야의 주니어가 모인 팀 ‘Team Lesser Panda’ 에서 개발중인 ‘맞춤 지식 ...",
  "content"  : "\n\n\n  ‘Qualk’ 현재 메인 페이지\n\n\n\nLink : https://qualk.co.kr/\n\nQualk\n\nGithub : https://github.com/sdf5771/tree/main/qualk-front\n\nqualk/qualk-front at main · sdf5771/qualk\n\n프로젝트 개요\n\n\n  기획, 설계, 런칭을 목적으로 만든 각 분야의 주니어가 모인 팀 ‘Team Lesser Panda’ 에서 개발중인 ‘맞춤 지식 정보 제공 플랫폼’\n  SEO를 통한 검색 유입\n  Google Ads 를 통한 광고 수익\n  Platform\n    \n      Web Application\n      Mobile Web Application\n    \n  \n\n\n역할\n\n\n  프로젝트 전체 인원\n    \n      Front-End Developer - 김섭우\n      Back-End Developer - 장병익\n      Designer - **장수진, 황현우\n      Data Analyst - **홍지호, 정수경\n    \n  \n  역할과 기여도\n    \n      프로젝트의 전반적인 Front-End 개발\n      서비스와 화면 구성 및 프로젝트 컨셉 기획\n      Technical SEO 및 URL 구조 설계\n    \n  \n\n\n프로젝트를 진행하며 학습한 사항\n\n\n  presentational &amp;amp; container 디자인 패턴 사용을 통한 코드의 관심사 분리\n  React Query 사용을 통한 Server State 관리 및 캐싱\n  URL 구조 설계 및 프로젝트 디렉토리 구조 및 아키텍처 고민\n    \n      기능 및 경로 별 그룹화\n    \n\n    \n  \n  Technical SEO에 관해 학습\n\n\n\n\n사용 중인 협업툴\n\n\n  태스크 관리를 위해 사용하는 툴 - Jira\n\n\n\n\n\n  회의록 및 필요 서류를 관리하는 툴 - Confluence\n\n\n\n\n\n\nQualk - 메인\n\n\n\n\n\n\n\n\n\nhttps://qualk.co.kr/\n\nQualk - 로그인\n\n\n\nhttps://qualk.co.kr/login\n\nQualk - 회원가입\n\n\n\nhttps://qualk.co.kr/createAccount\n\nQualk - 오픈북 퀴즈\n\n\n\nhttps://qualk.co.kr/quiz/{testName}\n\nQualk - 오픈북 퀴즈 상세보기\n\n\n\nhttps://qualk.co.kr/quiz/{testName}/{quizId}\n\nQualk - 퀴즈, 모의고사 리스트\n\n\n\nhttps://qualk.co.kr/quiz/test/{testName}\n\nQualk - 퀴즈 문제\n\n\n\nhttps://qualk.co.kr/quiz/test/{testName}/mockquiz?quiz={testId}\n\nQualk - 모의고사 시작\n\n\n\nhttps://qualk.co.kr/quiz/test/mockexam/start/\n\nQualk - 모의고사 문제\n\n\n\nhttps://qualk.co.kr/quiz/test/{testName}/mockexam?quiz={testId}\n\nQualk - 모의고사 시험결과 분석\n\n\n\nhttps://qualk.co.kr/quiz/test/mockexam/result/?test-id={testId}\n\nQualk - 검색 결과\n\n\n\nhttps://qualk.co.kr/quiz/search?keyword={searchKeyword}&amp;amp;type={searchType}\n\n\n\nSEO 작업 - 동적 메타태그 작성\n\nTechnical SEO를 위한 동적 메타태그 작성 feat.React Project\n\n\n\nLighthouse 성능 측정 결과\n\n\n"
  
} ,
  
  {
  
  "title"    : "반응형 웹 개발에 이해 및 Atomic Design 패턴 학습을 위한 토이 프로젝트",
  "category" : "",
  "tags"     : " OnBoarding, React, ReactQuery, Typescript",
  "url"      : "/portfolio/myshop",
  "date"     : "May 1, 2023",
  "excerpt"  : "@lastest-update readme post: 2023-05-26\n\n\n\nThis project is Initialized create-react-app\n\nMake Responsive Web Site\n\nSite Link : https://sdf5771.github.io/my-shop/\n\nDesign Pattern : Atomic Design Pattern\n\nUse Tech Stacks Version\n\n\n  react : 18.2.0\n ...",
  "content"  : "@lastest-update readme post: 2023-05-26\n\n\n\nThis project is Initialized create-react-app\n\nMake Responsive Web Site\n\nSite Link : https://sdf5771.github.io/my-shop/\n\nDesign Pattern : Atomic Design Pattern\n\nUse Tech Stacks Version\n\n\n  react : 18.2.0\n  gh-pages : 5.0.0\n  typescript : 4.9.5\n  react-responsive : 9.0.2\n  react-router-dom : 6.11.2\n  recoil : 0.7.7\n  styled-components : 5.3.10\n\n\n\n\n1. How to use\n\n\n  Install Dependency Modules\n\n\nnpm install\n\n\n\n  Start\n\n\nnpm start\n\n\n\n\n2. Package.json\n\n{\n  &quot;name&quot;: &quot;my-shop&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;private&quot;: true,\n  &quot;dependencies&quot;: {\n    &quot;@testing-library/jest-dom&quot;: &quot;^5.16.5&quot;,\n    &quot;@testing-library/react&quot;: &quot;^13.4.0&quot;,\n    &quot;@testing-library/user-event&quot;: &quot;^13.5.0&quot;,\n    &quot;@types/jest&quot;: &quot;^27.5.2&quot;,\n    &quot;@types/node&quot;: &quot;^16.18.32&quot;,\n    &quot;@types/react&quot;: &quot;^18.2.6&quot;,\n    &quot;@types/react-dom&quot;: &quot;^18.2.4&quot;,\n    &quot;@types/react-responsive&quot;: &quot;^8.0.5&quot;,\n    &quot;gh-pages&quot;: &quot;^5.0.0&quot;,\n    &quot;react&quot;: &quot;^18.2.0&quot;,\n    &quot;react-dom&quot;: &quot;^18.2.0&quot;,\n    &quot;react-responsive&quot;: &quot;^9.0.2&quot;,\n    &quot;react-router-dom&quot;: &quot;^6.11.2&quot;,\n    &quot;react-scripts&quot;: &quot;5.0.1&quot;,\n    &quot;recoil&quot;: &quot;^0.7.7&quot;,\n    &quot;styled-components&quot;: &quot;^5.3.10&quot;,\n    &quot;typescript&quot;: &quot;^4.9.5&quot;,\n    &quot;web-vitals&quot;: &quot;^2.1.4&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;react-scripts start&quot;,\n    &quot;build&quot;: &quot;react-scripts build&quot;,\n    &quot;test&quot;: &quot;react-scripts test&quot;,\n    &quot;eject&quot;: &quot;react-scripts eject&quot;,\n    &quot;deploy&quot;: &quot;gh-pages -d build&quot;,\n    &quot;predeploy&quot;: &quot;npm run build&quot;\n  },\n  &quot;eslintConfig&quot;: {\n    &quot;extends&quot;: [\n      &quot;react-app&quot;,\n      &quot;react-app/jest&quot;\n    ]\n  },\n  &quot;browserslist&quot;: {\n    &quot;production&quot;: [\n      &quot;&amp;gt;0.2%&quot;,\n      &quot;not dead&quot;,\n      &quot;not op_mini all&quot;\n    ],\n    &quot;development&quot;: [\n      &quot;last 1 chrome version&quot;,\n      &quot;last 1 firefox version&quot;,\n      &quot;last 1 safari version&quot;\n    ]\n  },\n  &quot;devDependencies&quot;: {\n    &quot;@types/styled-components&quot;: &quot;^5.1.26&quot;\n  },\n  &quot;homepage&quot;: &quot;https://sdf5771.github.io/my-shop/&quot;\n}\n\n\n\n\n3. Directories (Source Tree)\n\n.\n├── Router.tsx\n├── 📁 assets\n│   ├── 📁 images\n│   │   ├── bluetouth_earphone_black.svg\n│   │   ├── bluetouth_earphone_brown.svg\n│   │   ├── earphone_black.svg\n│   │   ├── earphone_gold.svg\n│   │   ├── headphone_black.svg\n│   │   ├── headphone_yellow.svg\n│   │   ├── index.ts\n│   │   ├── main_product.svg\n│   │   └── sub_product.svg\n│   └── 📁 logos\n│       ├── cart.svg\n│       ├── hamburgerIcon.svg\n│       ├── index.ts\n│       ├── logo.svg\n│       ├── profile.svg\n│       ├── search.svg\n│       └── sns_icon.svg\n├── 📁 components\n│   ├── 📁 Atoms\n│   │   ├── Button.tsx\n│   │   ├── Div.tsx\n│   │   ├── Input.tsx\n│   │   ├── Span.tsx\n│   │   └── index.ts\n│   ├── 📁 Molecules\n│   │   ├── FindColor.tsx\n│   │   ├── MenuIconList.tsx\n│   │   ├── MenuList.tsx\n│   │   └── index.ts\n│   ├── 📁 Organisms\n│   │   ├── HamburgerMenu.tsx\n│   │   ├── MainProductElement.tsx\n│   │   ├── ProductElement.tsx\n│   │   ├── SignUpForm.tsx\n│   │   ├── SubProductElement.tsx\n│   │   └── index.ts\n│   ├── 📁 Pages\n│   │   ├── Main.tsx\n│   │   └── index.ts\n│   └── 📁 Templates\n│       ├── Footer.tsx\n│       ├── Header.tsx\n│       └── index.ts\n├── index.tsx\n├── 📁 mediaQuery\n│   └── index.ts\n├── react-app-env.d.ts\n├── reportWebVitals.ts\n├── setupTests.ts\n├── 📁 state\n│   ├── hamBurgerMenuState.ts\n│   ├── index.ts\n│   ├── mainProduct.ts\n│   ├── products.ts\n│   └── subProduct.ts\n└── 📁 types\n    ├── index.ts\n    ├── mainProductType.ts\n    ├── productType.ts\n    └── subProductType.ts\n\n13 directories, 51 files\n\n"
  
} 
  
]
